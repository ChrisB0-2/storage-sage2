
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>storage-sage: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ChrisB0-2/storage-sage/cmd/storage-sage/main.go (3.1%)</option>
				
				<option value="file1">github.com/ChrisB0-2/storage-sage/internal/auditor/jsonl.go (87.1%)</option>
				
				<option value="file2">github.com/ChrisB0-2/storage-sage/internal/auditor/multi.go (100.0%)</option>
				
				<option value="file3">github.com/ChrisB0-2/storage-sage/internal/auditor/ndjson.go (0.0%)</option>
				
				<option value="file4">github.com/ChrisB0-2/storage-sage/internal/auditor/sqlite.go (81.5%)</option>
				
				<option value="file5">github.com/ChrisB0-2/storage-sage/internal/auth/apikey.go (93.3%)</option>
				
				<option value="file6">github.com/ChrisB0-2/storage-sage/internal/auth/auth.go (100.0%)</option>
				
				<option value="file7">github.com/ChrisB0-2/storage-sage/internal/auth/middleware.go (100.0%)</option>
				
				<option value="file8">github.com/ChrisB0-2/storage-sage/internal/auth/rbac.go (100.0%)</option>
				
				<option value="file9">github.com/ChrisB0-2/storage-sage/internal/config/config.go (4.2%)</option>
				
				<option value="file10">github.com/ChrisB0-2/storage-sage/internal/config/validate.go (74.0%)</option>
				
				<option value="file11">github.com/ChrisB0-2/storage-sage/internal/core/audit_helpers.go (81.8%)</option>
				
				<option value="file12">github.com/ChrisB0-2/storage-sage/internal/core/contracts.go (0.0%)</option>
				
				<option value="file13">github.com/ChrisB0-2/storage-sage/internal/daemon/daemon.go (84.7%)</option>
				
				<option value="file14">github.com/ChrisB0-2/storage-sage/internal/daemon/disk_unix.go (76.9%)</option>
				
				<option value="file15">github.com/ChrisB0-2/storage-sage/internal/executor/simple.go (71.5%)</option>
				
				<option value="file16">github.com/ChrisB0-2/storage-sage/internal/logger/logger.go (95.7%)</option>
				
				<option value="file17">github.com/ChrisB0-2/storage-sage/internal/logger/loki.go (93.7%)</option>
				
				<option value="file18">github.com/ChrisB0-2/storage-sage/internal/metrics/noop.go (0.0%)</option>
				
				<option value="file19">github.com/ChrisB0-2/storage-sage/internal/metrics/prometheus.go (95.2%)</option>
				
				<option value="file20">github.com/ChrisB0-2/storage-sage/internal/metrics/server.go (92.9%)</option>
				
				<option value="file21">github.com/ChrisB0-2/storage-sage/internal/notifier/webhook.go (79.2%)</option>
				
				<option value="file22">github.com/ChrisB0-2/storage-sage/internal/pidfile/pidfile_unix.go (77.8%)</option>
				
				<option value="file23">github.com/ChrisB0-2/storage-sage/internal/planner/planner.go (74.2%)</option>
				
				<option value="file24">github.com/ChrisB0-2/storage-sage/internal/policy/age.go (77.8%)</option>
				
				<option value="file25">github.com/ChrisB0-2/storage-sage/internal/policy/composite.go (96.8%)</option>
				
				<option value="file26">github.com/ChrisB0-2/storage-sage/internal/policy/exclusion.go (85.7%)</option>
				
				<option value="file27">github.com/ChrisB0-2/storage-sage/internal/policy/extension.go (100.0%)</option>
				
				<option value="file28">github.com/ChrisB0-2/storage-sage/internal/policy/size.go (85.7%)</option>
				
				<option value="file29">github.com/ChrisB0-2/storage-sage/internal/policy/stub.go (0.0%)</option>
				
				<option value="file30">github.com/ChrisB0-2/storage-sage/internal/safety/ancestor_symlink.go (89.1%)</option>
				
				<option value="file31">github.com/ChrisB0-2/storage-sage/internal/safety/safety.go (85.2%)</option>
				
				<option value="file32">github.com/ChrisB0-2/storage-sage/internal/scanner/device_unix.go (75.0%)</option>
				
				<option value="file33">github.com/ChrisB0-2/storage-sage/internal/scanner/walkdir.go (81.2%)</option>
				
				<option value="file34">github.com/ChrisB0-2/storage-sage/internal/trash/trash.go (69.3%)</option>
				
				<option value="file35">github.com/ChrisB0-2/storage-sage/internal/web/embed.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "encoding/json"
        "flag"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"

        "github.com/ChrisB0-2/storage-sage/internal/auditor"
        "github.com/ChrisB0-2/storage-sage/internal/auth"
        "github.com/ChrisB0-2/storage-sage/internal/config"
        "github.com/ChrisB0-2/storage-sage/internal/core"
        "github.com/ChrisB0-2/storage-sage/internal/daemon"
        "github.com/ChrisB0-2/storage-sage/internal/executor"
        "github.com/ChrisB0-2/storage-sage/internal/logger"
        "github.com/ChrisB0-2/storage-sage/internal/metrics"
        "github.com/ChrisB0-2/storage-sage/internal/notifier"
        "github.com/ChrisB0-2/storage-sage/internal/planner"
        "github.com/ChrisB0-2/storage-sage/internal/policy"
        "github.com/ChrisB0-2/storage-sage/internal/safety"
        "github.com/ChrisB0-2/storage-sage/internal/scanner"
        "github.com/ChrisB0-2/storage-sage/internal/trash"
)

// version is set via ldflags at build time.
var version = "dev"

// CLI flags
var (
        showVersion    = flag.Bool("version", false, "print version and exit")
        configPath     = flag.String("config", "", "path to YAML configuration file")
        root           = flag.String("root", "", "root directory to scan")
        mode           = flag.String("mode", "", "mode: dry-run or execute")
        maxItems       = flag.Int("max", 0, "max plan items to print")
        maxDepth       = flag.Int("depth", -1, "max depth (-1 = use config default)")
        minAgeDays     = flag.Int("min-age-days", -1, "minimum age in days (-1 = use config default)")
        auditPath      = flag.String("audit", "", "audit log path (jsonl)")
        auditDBPath    = flag.String("audit-db", "", "audit database path (sqlite)")
        protectedPaths = flag.String("protected", "", "comma-separated additional protected paths")
        allowDirDelete = flag.Bool("allow-dir-delete", false, "allow deletion of directories")
        minSizeMB      = flag.Int("min-size-mb", -1, "minimum file size in MB (-1 = use config default)")
        extensions     = flag.String("extensions", "", "comma-separated extensions to match")
        exclusions     = flag.String("exclude", "", "comma-separated glob patterns to exclude (e.g., '*.important,keep-*')")
        enableMetrics  = flag.Bool("metrics", false, "enable Prometheus metrics endpoint")
        metricsAddr    = flag.String("metrics-addr", "", "metrics server address (default :9090)")

        // Daemon mode flags
        daemonMode = flag.Bool("daemon", false, "run as long-running daemon")
        schedule   = flag.String("schedule", "", "run schedule (e.g., '1h', '30m', '@every 6h')")
        daemonAddr = flag.String("daemon-addr", ":8080", "daemon health endpoint address")
        pidFile    = flag.String("pid-file", "", "PID file path for single-instance enforcement")

        // Soft-delete flags
        trashPath = flag.String("trash-path", "", "move files to trash instead of permanent delete")

        // Loki flags
        enableLoki = flag.Bool("loki", false, "enable Loki log shipping")
        lokiURL    = flag.String("loki-url", "", "Loki server URL (default http://localhost:3100)")

        // Auth flags
        authEnabled = flag.Bool("auth", false, "enable API authentication")
        authKey     = flag.String("auth-key", "", "API key for authentication (format: ss_&lt;32 hex chars&gt;)")
)

func main() <span class="cov0" title="0">{
        // Check for subcommands before parsing flags
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                switch os.Args[1] </span>{
                case "query":<span class="cov0" title="0">
                        runQueryCmd(os.Args[2:])
                        return</span>
                case "stats":<span class="cov0" title="0">
                        runStatsCmd(os.Args[2:])
                        return</span>
                case "verify":<span class="cov0" title="0">
                        runVerifyCmd(os.Args[2:])
                        return</span>
                case "validate":<span class="cov0" title="0">
                        runValidateCmd(os.Args[2:])
                        return</span>
                case "trash":<span class="cov0" title="0">
                        runTrashCmd(os.Args[2:])
                        return</span>
                }
        }

        <span class="cov0" title="0">flag.Parse()

        if *showVersion </span><span class="cov0" title="0">{
                fmt.Println("storage-sage", version)
                return
        }</span>

        // 1. Load configuration
        <span class="cov0" title="0">cfg, err := loadConfig(*configPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to load config: %v\n", err)
                os.Exit(2)
        }</span>

        // 2. Merge CLI flags over config values
        <span class="cov0" title="0">mergeFlags(cfg)

        // 3. Validate final configuration
        if err := config.ValidateFinal(cfg); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: %v\n", err)
                os.Exit(2)
        }</span>

        // 4. Initialize logger from config
        <span class="cov0" title="0">log, lokiCleanup, err := initLogger(cfg.Logging)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to initialize logger: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if lokiCleanup != nil </span><span class="cov0" title="0">{
                defer lokiCleanup()
        }</span>

        <span class="cov0" title="0">log.Info("storage-sage starting",
                logger.F("mode", cfg.Execution.Mode),
                logger.F("roots", cfg.Scan.Roots),
        )

        // 5. Check for daemon mode
        if *daemonMode </span><span class="cov0" title="0">{
                if err := runDaemon(cfg, log); err != nil </span><span class="cov0" title="0">{
                        log.Error("daemon failed", logger.F("error", err.Error()))
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        // 6. Run main logic with logger-aware components (one-shot mode)
        <span class="cov0" title="0">if err := run(cfg, log); err != nil </span><span class="cov0" title="0">{
                log.Error("execution failed", logger.F("error", err.Error()))
                os.Exit(1)
        }</span>
}

// runQueryCmd handles the "query" subcommand for reviewing audit logs.
func runQueryCmd(args []string) <span class="cov0" title="0">{
        fs := flag.NewFlagSet("query", flag.ExitOnError)
        dbPath := fs.String("db", "", "audit database path (required)")
        since := fs.String("since", "", "show records since (e.g., '24h', '7d', '2024-01-01')")
        until := fs.String("until", "", "show records until (e.g., 'now', '2024-01-15')")
        action := fs.String("action", "", "filter by action (plan, delete, error)")
        level := fs.String("level", "", "filter by level (info, warn, error)")
        path := fs.String("path", "", "filter by path (partial match)")
        limit := fs.Int("limit", 100, "max records to return")
        jsonOut := fs.Bool("json", false, "output as JSON")

        fs.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: storage-sage query [options]\n\nQuery audit database for log review.\n\nOptions:\n")
                fs.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  storage-sage query -db audit.db -since 24h\n")
                fmt.Fprintf(os.Stderr, "  storage-sage query -db audit.db -action delete -limit 50\n")
                fmt.Fprintf(os.Stderr, "  storage-sage query -db audit.db -level error -json\n")
        }</span>

        <span class="cov0" title="0">_ = fs.Parse(args)

        if *dbPath == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: -db is required\n")
                fs.Usage()
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">sqlAud, err := auditor.NewSQLite(auditor.SQLiteConfig{Path: *dbPath})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to open database: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer sqlAud.Close()

        filter := auditor.QueryFilter{
                Action: *action,
                Level:  *level,
                Path:   *path,
                Limit:  *limit,
        }

        if *since != "" </span><span class="cov0" title="0">{
                filter.Since = parseTimeArg(*since)
        }</span>
        <span class="cov0" title="0">if *until != "" </span><span class="cov0" title="0">{
                filter.Until = parseTimeArg(*until)
        }</span>

        <span class="cov0" title="0">records, err := sqlAud.Query(context.Background(), filter)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: query failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *jsonOut </span><span class="cov0" title="0">{
                enc := json.NewEncoder(os.Stdout)
                enc.SetIndent("", "  ")
                if err := enc.Encode(records); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "error: failed to encode JSON: %v\n", err)
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("Found %d records:\n\n", len(records))
                for _, r := range records </span><span class="cov0" title="0">{
                        fmt.Printf("[%s] %s %s", r.Timestamp.Format("2006-01-02 15:04:05"), r.Level, r.Action)
                        if r.Path != "" </span><span class="cov0" title="0">{
                                fmt.Printf(" %s", r.Path)
                        }</span>
                        <span class="cov0" title="0">if r.BytesFreed &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf(" (%s freed)", formatBytesHuman(r.BytesFreed))
                        }</span>
                        <span class="cov0" title="0">if r.Error != "" </span><span class="cov0" title="0">{
                                fmt.Printf(" ERROR: %s", r.Error)
                        }</span>
                        <span class="cov0" title="0">fmt.Println()</span>
                }
        }
}

// runStatsCmd handles the "stats" subcommand for audit statistics.
func runStatsCmd(args []string) <span class="cov0" title="0">{
        fs := flag.NewFlagSet("stats", flag.ExitOnError)
        dbPath := fs.String("db", "", "audit database path (required)")
        jsonOut := fs.Bool("json", false, "output as JSON")

        fs.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: storage-sage stats [options]\n\nShow audit database statistics.\n\nOptions:\n")
                fs.PrintDefaults()
        }</span>

        <span class="cov0" title="0">_ = fs.Parse(args)

        if *dbPath == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: -db is required\n")
                fs.Usage()
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">sqlAud, err := auditor.NewSQLite(auditor.SQLiteConfig{Path: *dbPath})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to open database: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer sqlAud.Close()

        stats, err := sqlAud.Stats(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: stats failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *jsonOut </span><span class="cov0" title="0">{
                enc := json.NewEncoder(os.Stdout)
                enc.SetIndent("", "  ")
                if err := enc.Encode(stats); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "error: failed to encode JSON: %v\n", err)
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Println("Audit Database Statistics")
                fmt.Println("=========================")
                fmt.Printf("Total Records:     %d\n", stats.TotalRecords)
                fmt.Printf("First Record:      %s\n", stats.FirstRecord.Format("2006-01-02 15:04:05"))
                fmt.Printf("Last Record:       %s\n", stats.LastRecord.Format("2006-01-02 15:04:05"))
                fmt.Printf("Files Deleted:     %d\n", stats.FilesDeleted)
                fmt.Printf("Total Bytes Freed: %s\n", formatBytesHuman(stats.TotalBytesFreed))
                fmt.Printf("Errors:            %d\n", stats.Errors)
        }</span>
}

// runVerifyCmd handles the "verify" subcommand for integrity checking.
func runVerifyCmd(args []string) <span class="cov0" title="0">{
        fs := flag.NewFlagSet("verify", flag.ExitOnError)
        dbPath := fs.String("db", "", "audit database path (required)")

        fs.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: storage-sage verify [options]\n\nVerify audit database integrity (detect tampering).\n\nOptions:\n")
                fs.PrintDefaults()
        }</span>

        <span class="cov0" title="0">_ = fs.Parse(args)

        if *dbPath == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: -db is required\n")
                fs.Usage()
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">sqlAud, err := auditor.NewSQLite(auditor.SQLiteConfig{Path: *dbPath})
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to open database: %v\n", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer sqlAud.Close()

        tampered, err := sqlAud.VerifyIntegrity(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: verification failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(tampered) == 0 </span><span class="cov0" title="0">{
                fmt.Println("PASS: All records verified. No tampering detected.")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("FAIL: %d records have invalid checksums (possible tampering):\n", len(tampered))
                for _, id := range tampered </span><span class="cov0" title="0">{
                        fmt.Printf("  - Record ID: %d\n", id)
                }</span>
                <span class="cov0" title="0">os.Exit(1)</span>
        }
}

// runValidateCmd handles the "validate" subcommand for config validation.
func runValidateCmd(args []string) <span class="cov0" title="0">{
        fs := flag.NewFlagSet("validate", flag.ExitOnError)
        configFile := fs.String("config", "", "path to configuration file (required)")

        fs.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: storage-sage validate [options]\n\nValidate a configuration file without running cleanup.\n\nOptions:\n")
                fs.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  storage-sage validate -config /etc/storage-sage/config.yaml\n")
                fmt.Fprintf(os.Stderr, "  storage-sage validate -config ./config.yaml\n")
        }</span>

        <span class="cov0" title="0">_ = fs.Parse(args)

        if *configFile == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: -config is required\n")
                fs.Usage()
                os.Exit(2)
        }</span>

        // Load the configuration file
        <span class="cov0" title="0">cfg, err := config.Load(*configFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "FAIL: failed to load config: %v\n", err)
                os.Exit(1)
        }</span>

        // Validate the configuration
        <span class="cov0" title="0">if err := config.Validate(cfg); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "FAIL: %v", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("OK: configuration file %q is valid\n", *configFile)
        fmt.Printf("\nConfiguration summary:\n")
        fmt.Printf("  Roots:         %v\n", cfg.Scan.Roots)
        fmt.Printf("  Mode:          %s\n", cfg.Execution.Mode)
        fmt.Printf("  Min age:       %d days\n", cfg.Policy.MinAgeDays)
        if cfg.Policy.MinSizeMB &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Min size:      %d MB\n", cfg.Policy.MinSizeMB)
        }</span>
        <span class="cov0" title="0">if len(cfg.Policy.Extensions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Extensions:    %v\n", cfg.Policy.Extensions)
        }</span>
        <span class="cov0" title="0">if len(cfg.Policy.Exclusions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("  Exclusions:    %v\n", cfg.Policy.Exclusions)
        }</span>
        <span class="cov0" title="0">if cfg.Daemon.Enabled </span><span class="cov0" title="0">{
                fmt.Printf("  Daemon:        enabled (schedule: %s)\n", cfg.Daemon.Schedule)
        }</span>
        <span class="cov0" title="0">if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                fmt.Printf("  Metrics:       enabled\n")
        }</span>
        <span class="cov0" title="0">if cfg.Auth != nil &amp;&amp; cfg.Auth.Enabled </span><span class="cov0" title="0">{
                fmt.Printf("  Auth:          enabled\n")
        }</span>
}

// runTrashCmd handles the "trash" subcommand for managing soft-deleted files.
func runTrashCmd(args []string) <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                printTrashUsage()
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">switch args[0] </span>{
        case "list":<span class="cov0" title="0">
                runTrashList(args[1:])</span>
        case "restore":<span class="cov0" title="0">
                runTrashRestore(args[1:])</span>
        case "empty":<span class="cov0" title="0">
                runTrashEmpty(args[1:])</span>
        case "help", "-h", "--help":<span class="cov0" title="0">
                printTrashUsage()</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "error: unknown trash subcommand: %s\n", args[0])
                printTrashUsage()
                os.Exit(2)</span>
        }
}

func printTrashUsage() <span class="cov0" title="0">{
        fmt.Fprintf(os.Stderr, `Usage: storage-sage trash &lt;command&gt; [options]

Manage soft-deleted files in the trash directory.

Commands:
  list      List all items in trash
  restore   Restore an item from trash to its original location
  empty     Permanently delete items from trash

Examples:
  storage-sage trash list -path /var/lib/storage-sage/trash
  storage-sage trash restore -path /var/lib/storage-sage/trash -item &lt;trash-name&gt;
  storage-sage trash empty -path /var/lib/storage-sage/trash -older-than 7d

Run 'storage-sage trash &lt;command&gt; -h' for more information on a command.
`)
}</span>

// runTrashList lists all items currently in trash.
func runTrashList(args []string) <span class="cov0" title="0">{
        fs := flag.NewFlagSet("trash list", flag.ExitOnError)
        trashDir := fs.String("path", "", "trash directory path (required, or set in config)")
        configFile := fs.String("config", "", "path to config file (to read trash path)")
        jsonOut := fs.Bool("json", false, "output as JSON")

        fs.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: storage-sage trash list [options]\n\nList all items in the trash directory.\n\nOptions:\n")
                fs.PrintDefaults()
        }</span>

        <span class="cov0" title="0">_ = fs.Parse(args)

        path := resolveTrashPath(*trashDir, *configFile)
        if path == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: trash path required (use -path or configure execution.trash_path)\n")
                fs.Usage()
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">mgr, err := trash.New(trash.Config{TrashPath: path}, nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to open trash: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">items, err := mgr.List()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to list trash: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if *jsonOut </span><span class="cov0" title="0">{
                enc := json.NewEncoder(os.Stdout)
                enc.SetIndent("", "  ")
                if err := enc.Encode(items); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "error: failed to encode JSON: %v\n", err)
                        os.Exit(1)
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">if len(items) == 0 </span><span class="cov0" title="0">{
                fmt.Println("Trash is empty.")
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Trash directory: %s\n", path)
        fmt.Printf("Items: %d\n\n", len(items))

        // Calculate total size
        var totalSize int64
        for _, item := range items </span><span class="cov0" title="0">{
                totalSize += item.Size
        }</span>
        <span class="cov0" title="0">fmt.Printf("Total size: %s\n\n", formatBytesHuman(totalSize))

        // Print header
        fmt.Printf("%-40s  %-10s  %-20s  %s\n", "NAME", "SIZE", "TRASHED AT", "ORIGINAL PATH")
        fmt.Printf("%s\n", strings.Repeat("-", 100))

        for _, item := range items </span><span class="cov0" title="0">{
                name := item.Name
                if len(name) &gt; 40 </span><span class="cov0" title="0">{
                        name = name[:37] + "..."
                }</span>

                <span class="cov0" title="0">typeIndicator := ""
                if item.IsDir </span><span class="cov0" title="0">{
                        typeIndicator = "/"
                }</span>

                <span class="cov0" title="0">fmt.Printf("%-40s  %-10s  %-20s  %s%s\n",
                        name+typeIndicator,
                        formatBytesHuman(item.Size),
                        item.TrashedAt.Format("2006-01-02 15:04:05"),
                        item.OriginalPath,
                        "",
                )</span>
        }
}

// runTrashRestore restores an item from trash.
func runTrashRestore(args []string) <span class="cov0" title="0">{
        fs := flag.NewFlagSet("trash restore", flag.ExitOnError)
        trashDir := fs.String("path", "", "trash directory path (required, or set in config)")
        configFile := fs.String("config", "", "path to config file (to read trash path)")
        itemName := fs.String("item", "", "name of the item in trash to restore (required)")
        force := fs.Bool("force", false, "overwrite if destination exists")

        fs.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: storage-sage trash restore [options]\n\nRestore an item from trash to its original location.\n\nOptions:\n")
                fs.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  storage-sage trash restore -path /var/lib/storage-sage/trash -item 20240115-103000_abc12345_file.txt\n")
        }</span>

        <span class="cov0" title="0">_ = fs.Parse(args)

        path := resolveTrashPath(*trashDir, *configFile)
        if path == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: trash path required (use -path or configure execution.trash_path)\n")
                fs.Usage()
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">if *itemName == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: -item is required\n")
                fs.Usage()
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">mgr, err := trash.New(trash.Config{TrashPath: path}, nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to open trash: %v\n", err)
                os.Exit(1)
        }</span>

        // Find the item
        <span class="cov0" title="0">items, err := mgr.List()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to list trash: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">var targetItem *trash.TrashItem
        for i := range items </span><span class="cov0" title="0">{
                if items[i].Name == *itemName </span><span class="cov0" title="0">{
                        targetItem = &amp;items[i]
                        break</span>
                }
        }

        <span class="cov0" title="0">if targetItem == nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: item not found in trash: %s\n", *itemName)
                fmt.Fprintf(os.Stderr, "\nUse 'storage-sage trash list -path %s' to see available items.\n", path)
                os.Exit(1)
        }</span>

        // Check if destination exists
        <span class="cov0" title="0">if !*force </span><span class="cov0" title="0">{
                if _, err := os.Stat(targetItem.OriginalPath); err == nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "error: destination already exists: %s\n", targetItem.OriginalPath)
                        fmt.Fprintf(os.Stderr, "Use -force to overwrite.\n")
                        os.Exit(1)
                }</span>
        } else<span class="cov0" title="0"> {
                // Remove existing destination if force is set
                if _, err := os.Stat(targetItem.OriginalPath); err == nil </span><span class="cov0" title="0">{
                        if err := os.RemoveAll(targetItem.OriginalPath); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "error: failed to remove existing destination: %v\n", err)
                                os.Exit(1)
                        }</span>
                }
        }

        <span class="cov0" title="0">originalPath, err := mgr.Restore(targetItem.TrashPath)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: restore failed: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Printf("Restored: %s -&gt; %s\n", *itemName, originalPath)</span>
}

// trashEmptyOptions holds parsed options for trash empty command.
type trashEmptyOptions struct {
        path      string
        maxAge    time.Duration
        all       bool
        dryRun    bool
        force     bool
        olderThan string
}

// runTrashEmpty permanently deletes items from trash.
func runTrashEmpty(args []string) <span class="cov0" title="0">{
        opts := parseTrashEmptyFlags(args)

        mgr, err := trash.New(trash.Config{
                TrashPath: opts.path,
                MaxAge:    opts.maxAge,
        }, nil)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to open trash: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">items, err := mgr.List()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: failed to list trash: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if len(items) == 0 </span><span class="cov0" title="0">{
                fmt.Println("Trash is already empty.")
                return
        }</span>

        <span class="cov0" title="0">toDelete, totalBytes := filterTrashItems(items, opts)
        if len(toDelete) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No items older than %s found in trash.\n", opts.olderThan)
                return
        }</span>

        <span class="cov0" title="0">fmt.Printf("Items to delete: %d\n", len(toDelete))
        fmt.Printf("Space to free: %s\n\n", formatBytesHuman(totalBytes))

        if opts.dryRun </span><span class="cov0" title="0">{
                printTrashDryRun(toDelete)
                return
        }</span>

        <span class="cov0" title="0">if !opts.force &amp;&amp; !confirmTrashEmpty(len(toDelete), totalBytes) </span><span class="cov0" title="0">{
                fmt.Println("Aborted.")
                return
        }</span>

        <span class="cov0" title="0">executeTrashEmpty(mgr, toDelete, opts.all)</span>
}

// parseTrashEmptyFlags parses and validates flags for trash empty command.
func parseTrashEmptyFlags(args []string) trashEmptyOptions <span class="cov0" title="0">{
        fs := flag.NewFlagSet("trash empty", flag.ExitOnError)
        trashDir := fs.String("path", "", "trash directory path (required, or set in config)")
        configFile := fs.String("config", "", "path to config file (to read trash path)")
        olderThan := fs.String("older-than", "", "only delete items older than this (e.g., '7d', '24h')")
        all := fs.Bool("all", false, "delete ALL items (ignores -older-than)")
        dryRun := fs.Bool("dry-run", false, "show what would be deleted without actually deleting")
        force := fs.Bool("force", false, "skip confirmation prompt")

        fs.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: storage-sage trash empty [options]\n\nPermanently delete items from trash.\n\nOptions:\n")
                fs.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  storage-sage trash empty -path /var/lib/storage-sage/trash -older-than 7d\n")
                fmt.Fprintf(os.Stderr, "  storage-sage trash empty -path /var/lib/storage-sage/trash -all -force\n")
                fmt.Fprintf(os.Stderr, "  storage-sage trash empty -path /var/lib/storage-sage/trash -all -dry-run\n")
        }</span>

        <span class="cov0" title="0">_ = fs.Parse(args)

        path := resolveTrashPath(*trashDir, *configFile)
        if path == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: trash path required (use -path or configure execution.trash_path)\n")
                fs.Usage()
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">if !*all &amp;&amp; *olderThan == "" </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "error: must specify -older-than or -all\n")
                fs.Usage()
                os.Exit(2)
        }</span>

        <span class="cov0" title="0">var maxAge time.Duration
        if *olderThan != "" </span><span class="cov0" title="0">{
                maxAge = parseAgeDuration(*olderThan)
                if maxAge == 0 </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "error: invalid -older-than format: %s (use e.g., '7d', '24h', '30m')\n", *olderThan)
                        os.Exit(2)
                }</span>
        }

        <span class="cov0" title="0">return trashEmptyOptions{
                path:      path,
                maxAge:    maxAge,
                all:       *all,
                dryRun:    *dryRun,
                force:     *force,
                olderThan: *olderThan,
        }</span>
}

// filterTrashItems filters items based on age or all flag.
func filterTrashItems(items []trash.TrashItem, opts trashEmptyOptions) ([]trash.TrashItem, int64) <span class="cov0" title="0">{
        cutoff := time.Now().Add(-opts.maxAge)
        var toDelete []trash.TrashItem
        var totalBytes int64

        for _, item := range items </span><span class="cov0" title="0">{
                if opts.all || item.TrashedAt.Before(cutoff) </span><span class="cov0" title="0">{
                        toDelete = append(toDelete, item)
                        totalBytes += item.Size
                }</span>
        }
        <span class="cov0" title="0">return toDelete, totalBytes</span>
}

// printTrashDryRun prints what would be deleted in dry-run mode.
func printTrashDryRun(items []trash.TrashItem) <span class="cov0" title="0">{
        fmt.Println("Items that would be deleted:")
        for _, item := range items </span><span class="cov0" title="0">{
                age := time.Since(item.TrashedAt).Round(time.Hour)
                fmt.Printf("  - %s (age: %s, size: %s)\n", item.Name, age, formatBytesHuman(item.Size))
        }</span>
        <span class="cov0" title="0">fmt.Println("\n(dry-run mode, nothing was deleted)")</span>
}

// confirmTrashEmpty prompts user for confirmation.
func confirmTrashEmpty(count int, totalBytes int64) bool <span class="cov0" title="0">{
        fmt.Printf("This will permanently delete %d items (%s). Continue? [y/N] ", count, formatBytesHuman(totalBytes))
        var response string
        _, _ = fmt.Scanln(&amp;response)
        return response == "y" || response == "Y" || response == "yes"
}</span>

// executeTrashEmpty performs the actual deletion.
func executeTrashEmpty(mgr *trash.Manager, toDelete []trash.TrashItem, deleteAll bool) <span class="cov0" title="0">{
        if deleteAll </span><span class="cov0" title="0">{
                // Delete everything manually since Cleanup() respects maxAge
                var deletedCount int
                var freedBytes int64

                for _, item := range toDelete </span><span class="cov0" title="0">{
                        if err := os.RemoveAll(item.TrashPath); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "warning: failed to delete %s: %v\n", item.Name, err)
                                continue</span>
                        }
                        <span class="cov0" title="0">_ = os.Remove(item.TrashPath + ".meta")
                        deletedCount++
                        freedBytes += item.Size</span>
                }

                <span class="cov0" title="0">fmt.Printf("Deleted: %d items\n", deletedCount)
                fmt.Printf("Freed: %s\n", formatBytesHuman(freedBytes))</span>
        } else<span class="cov0" title="0"> {
                count, bytesFreed, err := mgr.Cleanup(context.Background())
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "error: cleanup failed: %v\n", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">fmt.Printf("Deleted: %d items\n", count)
                fmt.Printf("Freed: %s\n", formatBytesHuman(bytesFreed))</span>
        }
}

// resolveTrashPath determines the trash path from flag or config.
func resolveTrashPath(flagPath, configFile string) string <span class="cov0" title="0">{
        if flagPath != "" </span><span class="cov0" title="0">{
                return flagPath
        }</span>

        // Try to load config
        <span class="cov0" title="0">cfgPath := configFile
        if cfgPath == "" </span><span class="cov0" title="0">{
                cfgPath = config.FindConfigFile()
        }</span>

        <span class="cov0" title="0">if cfgPath != "" </span><span class="cov0" title="0">{
                cfg, err := config.Load(cfgPath)
                if err == nil &amp;&amp; cfg.Execution.TrashPath != "" </span><span class="cov0" title="0">{
                        return cfg.Execution.TrashPath
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// parseAgeDuration parses age strings like "7d", "24h", "30m"
func parseAgeDuration(s string) time.Duration <span class="cov0" title="0">{
        if len(s) &lt; 2 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">unit := s[len(s)-1]
        numStr := s[:len(s)-1]

        var n int
        if _, err := fmt.Sscanf(numStr, "%d", &amp;n); err != nil || n &lt;= 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">switch unit </span>{
        case 'd':<span class="cov0" title="0">
                return time.Duration(n) * 24 * time.Hour</span>
        case 'h':<span class="cov0" title="0">
                return time.Duration(n) * time.Hour</span>
        case 'm':<span class="cov0" title="0">
                return time.Duration(n) * time.Minute</span>
        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// parseTimeArg parses a time argument like "24h", "7d", or "2024-01-01"
func parseTimeArg(s string) time.Time <span class="cov8" title="1">{
        // Try duration format first (e.g., "24h", "7d")
        if len(s) &gt; 1 </span><span class="cov8" title="1">{
                unit := s[len(s)-1]
                numStr := s[:len(s)-1]
                var multiplier time.Duration
                switch unit </span>{
                case 'h':<span class="cov8" title="1">
                        multiplier = time.Hour</span>
                case 'd':<span class="cov8" title="1">
                        multiplier = 24 * time.Hour</span>
                case 'm':<span class="cov8" title="1">
                        multiplier = time.Minute</span>
                }
                <span class="cov8" title="1">if multiplier &gt; 0 </span><span class="cov8" title="1">{
                        var n int
                        if _, err := fmt.Sscanf(numStr, "%d", &amp;n); err == nil &amp;&amp; n &gt; 0 </span><span class="cov8" title="1">{
                                return time.Now().Add(-time.Duration(n) * multiplier)
                        }</span>
                }
        }

        // Try RFC3339
        <span class="cov8" title="1">if t, err := time.Parse(time.RFC3339, s); err == nil </span><span class="cov0" title="0">{
                return t
        }</span>

        // Try date format
        <span class="cov8" title="1">if t, err := time.Parse("2006-01-02", s); err == nil </span><span class="cov8" title="1">{
                return t
        }</span>

        <span class="cov8" title="1">return time.Time{}</span>
}

// formatBytesHuman formats bytes in human-readable format
func formatBytesHuman(b int64) string <span class="cov8" title="1">{
        const unit = 1024
        if b &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d B", b)
        }</span>
        <span class="cov8" title="1">div, exp := int64(unit), 0
        for n := b / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMGTPE"[exp])</span>
}

// runDaemon starts storage-sage in daemon mode.
func runDaemon(cfg *config.Config, log logger.Logger) error <span class="cov0" title="0">{
        // Get schedule from flag or config
        sched := *schedule
        if sched == "" </span><span class="cov0" title="0">{
                sched = cfg.Daemon.Schedule
        }</span>
        <span class="cov0" title="0">if sched == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("daemon mode requires -schedule flag or daemon.schedule in config")
        }</span>

        // Get HTTP address from flag (already has default)
        <span class="cov0" title="0">addr := *daemonAddr

        log.Info("starting daemon mode",
                logger.F("schedule", sched),
                logger.F("http_addr", addr),
        )

        // Initialize metrics (Prometheus or Noop) - persistent for daemon lifetime
        var m core.Metrics
        var metricsServer *metrics.Server
        if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                m = metrics.NewPrometheus(nil)
                metricsServer = metrics.NewServer(cfg.Daemon.MetricsAddr)

                // Start metrics server in background (runs for daemon lifetime)
                go func() </span><span class="cov0" title="0">{
                        log.Info("metrics server starting", logger.F("addr", metricsServer.Addr()))
                        if err := metricsServer.Start(); err != nil </span><span class="cov0" title="0">{
                                log.Error("metrics server error", logger.F("error", err.Error()))
                        }</span>
                }()

                // Shutdown metrics server when daemon exits
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        log.Info("metrics server stopping")
                        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 5*time.Second)
                        defer shutdownCancel()
                        if err := metricsServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                                log.Warn("metrics server shutdown error", logger.F("error", err.Error()))
                        }</span>
                }()
        } else<span class="cov0" title="0"> {
                m = metrics.NewNoop()
        }</span>

        // Initialize webhook notifier
        <span class="cov0" title="0">notify := createNotifier(cfg.Notifications, log)

        // Initialize SQLite auditor for API endpoints (query/stats)
        // This is separate from the per-run auditor in runCore, used for reading audit data
        var sqlAud *auditor.SQLiteAuditor
        if cfg.Execution.AuditDBPath != "" </span><span class="cov0" title="0">{
                var err error
                sqlAud, err = auditor.NewSQLite(auditor.SQLiteConfig{
                        Path: cfg.Execution.AuditDBPath,
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn("failed to initialize audit DB for API", logger.F("error", err.Error()))
                }</span> else<span class="cov0" title="0"> {
                        log.Info("audit API enabled", logger.F("path", cfg.Execution.AuditDBPath))
                        defer func() </span><span class="cov0" title="0">{
                                if err := sqlAud.Close(); err != nil </span><span class="cov0" title="0">{
                                        log.Warn("audit DB close error", logger.F("error", err.Error()))
                                }</span>
                        }()
                }
        }

        // Create the run function that executes a single cleanup cycle
        // Uses shared metrics instance for persistent metrics
        // Wraps with webhook notifications
        <span class="cov0" title="0">runFunc := func(ctx context.Context) error </span><span class="cov0" title="0">{
                startTime := time.Now()
                rootStr := ""
                if len(cfg.Scan.Roots) &gt; 0 </span><span class="cov0" title="0">{
                        rootStr = cfg.Scan.Roots[0]
                }</span>

                // Notify cleanup started (fire-and-forget)
                <span class="cov0" title="0">_ = notify.Notify(ctx, notifier.WebhookPayload{
                        Event:     notifier.EventCleanupStarted,
                        Timestamp: startTime,
                        Message:   fmt.Sprintf("Cleanup started for %s", rootStr),
                })

                // Run cleanup
                err := runCore(cfg, log, m)

                // Build summary and notify
                duration := time.Since(startTime)
                payload := notifier.WebhookPayload{
                        Timestamp: time.Now(),
                        Summary: &amp;notifier.CleanupSummary{
                                Root:        rootStr,
                                Mode:        cfg.Execution.Mode,
                                Duration:    duration.Round(time.Second).String(),
                                StartedAt:   startTime,
                                CompletedAt: time.Now(),
                        },
                }

                if err != nil </span><span class="cov0" title="0">{
                        payload.Event = notifier.EventCleanupFailed
                        payload.Message = fmt.Sprintf("Cleanup failed: %v", err)
                        payload.Summary.ErrorMessages = []string{err.Error()}
                        payload.Summary.Errors = 1
                }</span> else<span class="cov0" title="0"> {
                        payload.Event = notifier.EventCleanupCompleted
                        payload.Message = "Cleanup completed successfully"
                        // Record successful run timestamp for metrics
                        m.SetLastRunTimestamp(time.Now())
                }</span>

                <span class="cov0" title="0">_ = notify.Notify(ctx, payload)

                return err</span>
        }

        // Initialize auth middleware if enabled
        <span class="cov0" title="0">var authMW *auth.Middleware
        var rbacMW *auth.RBACMiddleware

        if cfg.Auth != nil &amp;&amp; cfg.Auth.Enabled </span><span class="cov0" title="0">{
                authenticators := []auth.Authenticator{}

                if cfg.Auth.APIKeys != nil &amp;&amp; cfg.Auth.APIKeys.Enabled </span><span class="cov0" title="0">{
                        apiKeyAuth, err := auth.NewAPIKeyAuthenticator(auth.APIKeyConfig{
                                Enabled:    cfg.Auth.APIKeys.Enabled,
                                Key:        cfg.Auth.APIKeys.Key,
                                KeyEnv:     cfg.Auth.APIKeys.KeyEnv,
                                KeysFile:   cfg.Auth.APIKeys.KeysFile,
                                HeaderName: cfg.Auth.APIKeys.HeaderName,
                        }, log)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("auth setup failed: %w", err)
                        }</span>
                        <span class="cov0" title="0">authenticators = append(authenticators, apiKeyAuth)</span>
                }

                <span class="cov0" title="0">if len(authenticators) &gt; 0 </span><span class="cov0" title="0">{
                        publicPaths := cfg.Auth.PublicPaths
                        if publicPaths == nil </span><span class="cov0" title="0">{
                                publicPaths = []string{"/health"}
                        }</span>
                        <span class="cov0" title="0">authMW = auth.NewMiddleware(log, authenticators, publicPaths)
                        rbacMW = auth.NewRBACMiddleware(auth.DefaultPermissions(), log)
                        log.Info("authentication enabled", logger.F("methods", len(authenticators)))</span>
                }
        }

        // Initialize trash manager for API endpoints
        <span class="cov0" title="0">var trashMgr *trash.Manager
        if cfg.Execution.TrashPath != "" </span><span class="cov0" title="0">{
                var err error
                trashMgr, err = trash.New(trash.Config{
                        TrashPath: cfg.Execution.TrashPath,
                        MaxAge:    cfg.Execution.TrashMaxAge,
                }, log)
                if err != nil </span><span class="cov0" title="0">{
                        log.Warn("failed to initialize trash manager for API", logger.F("error", err.Error()))
                }</span> else<span class="cov0" title="0"> {
                        log.Info("trash API enabled", logger.F("path", cfg.Execution.TrashPath))
                }</span>
        }

        // Create and run daemon with config and auditor for API endpoints
        <span class="cov0" title="0">d := daemon.New(log, runFunc, daemon.Config{
                Schedule:       sched,
                HTTPAddr:       addr,
                TriggerTimeout: cfg.Daemon.TriggerTimeout,
                PIDFile:        cfg.Daemon.PIDFile,
                AppConfig:      cfg,
                Auditor:        sqlAud,
                Trash:          trashMgr,
                AuthMiddleware: authMW,
                RBACMiddleware: rbacMW,
        })

        return d.Run(context.Background())</span>
}

// loadConfig loads configuration from file or returns defaults.
func loadConfig(path string) (*config.Config, error) <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                // Try to find config in standard locations
                path = config.FindConfigFile()
        }</span>

        <span class="cov0" title="0">cfg, err := config.LoadOrDefault(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Validate loaded config (but not final - CLI may fix issues)
        <span class="cov0" title="0">if path != "" </span><span class="cov0" title="0">{
                if err := config.Validate(cfg); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid config file: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return cfg, nil</span>
}

// mergeFlags applies CLI flag values over config values.
// CLI flags take precedence (only if explicitly set).
//
//nolint:gocyclo // Flag merging is repetitive but straightforward; splitting would obscure logic
func mergeFlags(cfg *config.Config) <span class="cov0" title="0">{
        // Helper to check if a flag was explicitly set
        flagSet := make(map[string]bool)
        flag.Visit(func(f *flag.Flag) </span><span class="cov0" title="0">{
                flagSet[f.Name] = true
        }</span>)

        // Merge root (-root overrides/replaces scan.roots)
        <span class="cov0" title="0">if flagSet["root"] &amp;&amp; *root != "" </span><span class="cov0" title="0">{
                cfg.Scan.Roots = []string{filepath.Clean(*root)}
        }</span>

        // Merge mode
        <span class="cov0" title="0">if flagSet["mode"] &amp;&amp; *mode != "" </span><span class="cov0" title="0">{
                cfg.Execution.Mode = *mode
        }</span>

        // Merge max-items
        <span class="cov0" title="0">if flagSet["max"] &amp;&amp; *maxItems &gt; 0 </span><span class="cov0" title="0">{
                cfg.Execution.MaxItems = *maxItems
        }</span>

        // Merge depth
        <span class="cov0" title="0">if flagSet["depth"] &amp;&amp; *maxDepth &gt;= 0 </span><span class="cov0" title="0">{
                cfg.Scan.MaxDepth = *maxDepth
        }</span>

        // Merge min-age-days
        <span class="cov0" title="0">if flagSet["min-age-days"] &amp;&amp; *minAgeDays &gt;= 0 </span><span class="cov0" title="0">{
                cfg.Policy.MinAgeDays = *minAgeDays
        }</span>

        // Merge min-size-mb
        <span class="cov0" title="0">if flagSet["min-size-mb"] &amp;&amp; *minSizeMB &gt;= 0 </span><span class="cov0" title="0">{
                cfg.Policy.MinSizeMB = *minSizeMB
        }</span>

        // Merge audit path
        <span class="cov0" title="0">if flagSet["audit"] </span><span class="cov0" title="0">{
                cfg.Execution.AuditPath = *auditPath
        }</span>
        <span class="cov0" title="0">if flagSet["audit-db"] </span><span class="cov0" title="0">{
                cfg.Execution.AuditDBPath = *auditDBPath
        }</span>

        // Merge protected paths (append, don't replace)
        <span class="cov0" title="0">if flagSet["protected"] &amp;&amp; *protectedPaths != "" </span><span class="cov0" title="0">{
                for _, p := range strings.Split(*protectedPaths, ",") </span><span class="cov0" title="0">{
                        if p = strings.TrimSpace(p); p != "" </span><span class="cov0" title="0">{
                                cfg.Safety.ProtectedPaths = append(cfg.Safety.ProtectedPaths, p)
                        }</span>
                }
        }

        // Merge allow-dir-delete
        <span class="cov0" title="0">if flagSet["allow-dir-delete"] </span><span class="cov0" title="0">{
                cfg.Safety.AllowDirDelete = *allowDirDelete
        }</span>

        // Merge extensions
        <span class="cov0" title="0">if flagSet["extensions"] &amp;&amp; *extensions != "" </span><span class="cov0" title="0">{
                var exts []string
                for _, e := range strings.Split(*extensions, ",") </span><span class="cov0" title="0">{
                        if e = strings.TrimSpace(e); e != "" </span><span class="cov0" title="0">{
                                if !strings.HasPrefix(e, ".") </span><span class="cov0" title="0">{
                                        e = "." + e
                                }</span>
                                <span class="cov0" title="0">exts = append(exts, e)</span>
                        }
                }
                <span class="cov0" title="0">cfg.Policy.Extensions = exts</span>
        }

        // Merge exclusions
        <span class="cov0" title="0">if flagSet["exclude"] &amp;&amp; *exclusions != "" </span><span class="cov0" title="0">{
                var excl []string
                for _, e := range strings.Split(*exclusions, ",") </span><span class="cov0" title="0">{
                        if e = strings.TrimSpace(e); e != "" </span><span class="cov0" title="0">{
                                excl = append(excl, e)
                        }</span>
                }
                <span class="cov0" title="0">cfg.Policy.Exclusions = excl</span>
        }

        // Merge metrics flags
        <span class="cov0" title="0">if flagSet["metrics"] </span><span class="cov0" title="0">{
                cfg.Metrics.Enabled = *enableMetrics
        }</span>
        <span class="cov0" title="0">if flagSet["metrics-addr"] &amp;&amp; *metricsAddr != "" </span><span class="cov0" title="0">{
                cfg.Daemon.MetricsAddr = *metricsAddr
        }</span>

        // Merge Loki flags
        <span class="cov0" title="0">if flagSet["loki"] </span><span class="cov0" title="0">{
                if cfg.Logging.Loki == nil </span><span class="cov0" title="0">{
                        cfg.Logging.Loki = &amp;config.LokiConfig{}
                }</span>
                <span class="cov0" title="0">cfg.Logging.Loki.Enabled = *enableLoki</span>
        }
        <span class="cov0" title="0">if flagSet["loki-url"] &amp;&amp; *lokiURL != "" </span><span class="cov0" title="0">{
                if cfg.Logging.Loki == nil </span><span class="cov0" title="0">{
                        cfg.Logging.Loki = &amp;config.LokiConfig{}
                }</span>
                <span class="cov0" title="0">cfg.Logging.Loki.URL = *lokiURL</span>
        }

        // Merge auth flags
        <span class="cov0" title="0">if flagSet["auth"] </span><span class="cov0" title="0">{
                if cfg.Auth == nil </span><span class="cov0" title="0">{
                        cfg.Auth = &amp;config.AuthConfig{}
                }</span>
                <span class="cov0" title="0">cfg.Auth.Enabled = *authEnabled</span>
        }
        <span class="cov0" title="0">if flagSet["auth-key"] &amp;&amp; *authKey != "" </span><span class="cov0" title="0">{
                if cfg.Auth == nil </span><span class="cov0" title="0">{
                        cfg.Auth = &amp;config.AuthConfig{}
                }</span>
                <span class="cov0" title="0">cfg.Auth.Enabled = true
                if cfg.Auth.APIKeys == nil </span><span class="cov0" title="0">{
                        cfg.Auth.APIKeys = &amp;config.APIKeyConfig{Enabled: true}
                }</span>
                <span class="cov0" title="0">cfg.Auth.APIKeys.Enabled = true
                cfg.Auth.APIKeys.Key = *authKey</span>
        }

        // Merge PID file flag
        <span class="cov0" title="0">if flagSet["pid-file"] &amp;&amp; *pidFile != "" </span><span class="cov0" title="0">{
                cfg.Daemon.PIDFile = *pidFile
        }</span>

        // Merge trash path flag
        <span class="cov0" title="0">if flagSet["trash-path"] &amp;&amp; *trashPath != "" </span><span class="cov0" title="0">{
                cfg.Execution.TrashPath = *trashPath
        }</span>
}

// initLogger creates a logger based on configuration.
// Returns the logger and an optional cleanup function for Loki.
func initLogger(cfg config.LoggingConfig) (logger.Logger, func(), error) <span class="cov0" title="0">{
        level, err := logger.ParseLevel(cfg.Level)
        if err != nil </span><span class="cov0" title="0">{
                level = logger.LevelInfo
        }</span>

        <span class="cov0" title="0">var output io.Writer
        switch cfg.Output </span>{
        case "", "stderr":<span class="cov0" title="0">
                output = os.Stderr</span>
        case "stdout":<span class="cov0" title="0">
                output = os.Stdout</span>
        default:<span class="cov0" title="0">
                // File output
                f, err := os.OpenFile(cfg.Output, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o644)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to open log file: %w", err)
                }</span>
                <span class="cov0" title="0">output = f</span>
        }

        <span class="cov0" title="0">baseLog := logger.New(level, output)

        // Wrap with Loki if enabled
        if cfg.Loki != nil &amp;&amp; cfg.Loki.Enabled </span><span class="cov0" title="0">{
                lokiCfg := logger.LokiConfig{
                        URL:       cfg.Loki.URL,
                        BatchSize: cfg.Loki.BatchSize,
                        BatchWait: cfg.Loki.BatchWait,
                        Labels:    cfg.Loki.Labels,
                        TenantID:  cfg.Loki.TenantID,
                }
                lokiLog := logger.NewLokiLogger(baseLog, lokiCfg)

                cleanup := func() </span><span class="cov0" title="0">{
                        if err := lokiLog.Close(); err != nil </span><span class="cov0" title="0">{
                                baseLog.Warn("loki shutdown error", logger.F("error", err.Error()))
                        }</span>
                }

                <span class="cov0" title="0">return lokiLog, cleanup, nil</span>
        }

        <span class="cov0" title="0">return baseLog, nil, nil</span>
}

// run executes storage-sage in one-shot mode (manages its own metrics lifecycle).
func run(cfg *config.Config, log logger.Logger) error <span class="cov0" title="0">{
        // Initialize metrics (Prometheus or Noop)
        var m core.Metrics
        var metricsServer *metrics.Server
        if cfg.Metrics.Enabled </span><span class="cov0" title="0">{
                m = metrics.NewPrometheus(nil)
                metricsServer = metrics.NewServer(cfg.Daemon.MetricsAddr)

                // Start metrics server in background
                go func() </span><span class="cov0" title="0">{
                        log.Info("metrics server starting", logger.F("addr", metricsServer.Addr()))
                        if err := metricsServer.Start(); err != nil </span><span class="cov0" title="0">{
                                log.Error("metrics server error", logger.F("error", err.Error()))
                        }</span>
                }()

                // Shutdown metrics server when done
                <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                        shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 5*time.Second)
                        defer shutdownCancel()
                        if err := metricsServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                                log.Warn("metrics server shutdown error", logger.F("error", err.Error()))
                        }</span>
                }()
        } else<span class="cov0" title="0"> {
                m = metrics.NewNoop()
        }</span>

        <span class="cov0" title="0">return runCore(cfg, log, m)</span>
}

// runCore executes the main storage-sage cleanup logic with provided metrics.
//
//nolint:gocyclo // Main orchestration function; complexity reflects feature breadth
func runCore(cfg *config.Config, log logger.Logger, m core.Metrics) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), cfg.Execution.Timeout)
        defer cancel()

        runMode := core.Mode(cfg.Execution.Mode)

        // Auditor (optional) - supports both JSONL and SQLite
        var aud core.Auditor
        var auditors []core.Auditor

        // JSONL auditor
        if cfg.Execution.AuditPath != "" </span><span class="cov0" title="0">{
                a, aerr := auditor.NewJSONL(cfg.Execution.AuditPath)
                if aerr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("audit jsonl init failed: %w", aerr)
                }</span>
                <span class="cov0" title="0">auditors = append(auditors, a)
                defer func() </span><span class="cov0" title="0">{
                        if err := a.Err(); err != nil </span><span class="cov0" title="0">{
                                log.Warn("audit write error", logger.F("error", err.Error()))
                        }</span>
                        <span class="cov0" title="0">_ = a.Close()</span>
                }()
        }

        // SQLite auditor (for long-term storage)
        <span class="cov0" title="0">if cfg.Execution.AuditDBPath != "" </span><span class="cov0" title="0">{
                sqlAud, err := auditor.NewSQLite(auditor.SQLiteConfig{
                        Path: cfg.Execution.AuditDBPath,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("audit sqlite init failed: %w", err)
                }</span>
                <span class="cov0" title="0">auditors = append(auditors, sqlAud)
                log.Info("sqlite audit enabled", logger.F("path", cfg.Execution.AuditDBPath))
                defer func() </span><span class="cov0" title="0">{
                        if err := sqlAud.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Warn("audit db close error", logger.F("error", err.Error()))
                        }</span>
                }()
        }

        // Combine auditors if multiple configured
        <span class="cov0" title="0">if len(auditors) == 1 </span><span class="cov0" title="0">{
                aud = auditors[0]
        }</span> else<span class="cov0" title="0"> if len(auditors) &gt; 1 </span><span class="cov0" title="0">{
                aud = auditor.NewMulti(auditors...)
        }</span>

        // Components with logger and metrics injection
        <span class="cov0" title="0">sc := scanner.NewWalkDirWithMetrics(log, m)
        pl := planner.NewSimpleWithMetrics(log, m)
        safe := safety.NewWithLogger(log)

        // Build policy from config
        pol := buildPolicy(cfg.Policy, log)

        // Environment snapshot
        env := core.EnvSnapshot{
                Now:         time.Now(),
                DiskUsedPct: 0,
                CPUUsedPct:  0,
        }

        // Safety config
        safetyCfg := core.SafetyConfig{
                AllowedRoots:         cfg.Scan.Roots,
                ProtectedPaths:       cfg.Safety.ProtectedPaths,
                AllowDirDelete:       cfg.Safety.AllowDirDelete,
                EnforceMountBoundary: cfg.Safety.EnforceMountBoundary,
        }

        req := core.ScanRequest{
                Roots:        cfg.Scan.Roots,
                Recursive:    cfg.Scan.Recursive,
                MaxDepth:     cfg.Scan.MaxDepth,
                IncludeDirs:  cfg.Safety.AllowDirDelete,
                IncludeFiles: cfg.Scan.IncludeFiles,
        }

        log.Debug("starting scan", logger.F("roots", cfg.Scan.Roots))

        cands, errc := sc.Scan(ctx, req)

        plan, err := pl.BuildPlan(ctx, cands, pol, safe, env, safetyCfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("build plan failed: %w", err)
        }</span>

        // Priority ordering: allowed+safe first, then higher score first (stable, deterministic).
        <span class="cov0" title="0">sortPlan(plan)

        // Drain scanner error channel (non-blocking after scan completes)
        select </span>{
        case scanErr := &lt;-errc:<span class="cov0" title="0">
                if scanErr != nil &amp;&amp; scanErr != context.Canceled </span><span class="cov0" title="0">{
                        return fmt.Errorf("scan error: %w", scanErr)
                }</span>
        default:<span class="cov0" title="0"></span>
        }

        // Use first root for audit events (for backward compatibility)
        <span class="cov0" title="0">auditRoot := ""
        if len(cfg.Scan.Roots) &gt; 0 </span><span class="cov0" title="0">{
                auditRoot = cfg.Scan.Roots[0]
        }</span>

        // Plan-time audit: record the plan (allowed/blocked + reasons) before any execution.
        <span class="cov0" title="0">if aud != nil </span><span class="cov0" title="0">{
                for _, it := range plan </span><span class="cov0" title="0">{
                        aud.Record(ctx, core.NewPlanAuditEvent(auditRoot, runMode, it))
                }</span>
        }

        // Print plan summary
        <span class="cov0" title="0">printPlanSummary(plan, runMode, cfg.Scan.Roots)

        // Execute pass (only in execute mode)
        if runMode == core.ModeExecute </span><span class="cov0" title="0">{
                del := executor.NewSimpleWithMetrics(safe, safetyCfg, log, m)

                // Configure soft-delete if trash path is set
                if cfg.Execution.TrashPath != "" </span><span class="cov0" title="0">{
                        trashMgr, err := trash.New(trash.Config{
                                TrashPath: cfg.Execution.TrashPath,
                                MaxAge:    cfg.Execution.TrashMaxAge,
                        }, log)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to initialize trash manager: %w", err)
                        }</span>
                        <span class="cov0" title="0">del.WithTrash(trashMgr)
                        log.Info("soft-delete enabled", logger.F("trash_path", cfg.Execution.TrashPath))</span>
                }

                <span class="cov0" title="0">var (
                        actionsAttempted int
                        deletedCount     int
                        executeDenied    int
                        alreadyGone      int
                        deleteFailed     int
                        bytesFreed       int64
                )

                for _, it := range plan </span><span class="cov0" title="0">{
                        // Only attempt actions for items already allowed by policy + scan-time safety.
                        if !it.Decision.Allow || !it.Safety.Allowed </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">actionsAttempted++
                        ar := del.Execute(ctx, it, runMode)
                        if aud != nil </span><span class="cov0" title="0">{
                                aud.Record(ctx, core.NewExecuteAuditEvent(auditRoot, runMode, it, ar))
                        }</span>

                        <span class="cov0" title="0">if ar.Deleted </span><span class="cov0" title="0">{
                                deletedCount++
                                bytesFreed += ar.BytesFreed
                        }</span>

                        // Outcome accounting
                        <span class="cov0" title="0">if len(ar.Reason) &gt;= len("safety_deny_execute:") &amp;&amp; ar.Reason[:len("safety_deny_execute:")] == "safety_deny_execute:" </span><span class="cov0" title="0">{
                                executeDenied++
                        }</span> else<span class="cov0" title="0"> if ar.Reason == "already_gone" </span><span class="cov0" title="0">{
                                alreadyGone++
                        }</span> else<span class="cov0" title="0"> if ar.Reason == "delete_failed" </span><span class="cov0" title="0">{
                                deleteFailed++
                        }</span>
                }

                <span class="cov0" title="0">fmt.Printf("actions attempted: %d\n", actionsAttempted)
                fmt.Printf("deleted: %d\n", deletedCount)
                fmt.Printf("bytes freed: %d\n", bytesFreed)
                fmt.Printf("execute denies: %d\n", executeDenied)
                fmt.Printf("already gone: %d\n", alreadyGone)
                fmt.Printf("delete failed: %d\n", deleteFailed)
                fmt.Println()

                log.Info("execution complete",
                        logger.F("deleted", deletedCount),
                        logger.F("bytes_freed", bytesFreed),
                )</span>
        }

        <span class="cov0" title="0">limit := cfg.Execution.MaxItems
        if limit &gt; len(plan) </span><span class="cov0" title="0">{
                limit = len(plan)
        }</span>

        <span class="cov0" title="0">fmt.Printf("First %d plan items:\n", limit)

        for i := 0; i &lt; limit; i++ </span><span class="cov0" title="0">{
                it := plan[i]
                fmt.Printf("- %s | score=%d | policy=%s | safety=%s\n",
                        it.Candidate.Path,
                        it.Decision.Score,
                        it.Decision.Reason,
                        it.Safety.Reason,
                )
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// reasonKey collapses reasons like "symlink_self:/path/to/file" -&gt; "symlink_self"
func reasonKey(s string) string <span class="cov0" title="0">{
        if i := strings.IndexByte(s, ':'); i &gt; 0 </span><span class="cov0" title="0">{
                return s[:i]
        }</span>
        <span class="cov0" title="0">return s</span>
}

// printPlanSummary calculates and prints a summary of the cleanup plan.
func printPlanSummary(plan []core.PlanItem, runMode core.Mode, roots []string) <span class="cov0" title="0">{
        var (
                total         = len(plan)
                policyAllowed int
                safetyAllowed int
                reasonCounts  = map[string]int{}
                eligibleBytes int64
        )

        for _, it := range plan </span><span class="cov0" title="0">{
                if !it.Safety.Allowed </span><span class="cov0" title="0">{
                        reasonCounts[reasonKey(it.Safety.Reason)]++
                }</span>
                <span class="cov0" title="0">if it.Decision.Allow </span><span class="cov0" title="0">{
                        policyAllowed++
                }</span>
                <span class="cov0" title="0">if it.Safety.Allowed </span><span class="cov0" title="0">{
                        safetyAllowed++
                }</span>
                <span class="cov0" title="0">if it.Decision.Allow &amp;&amp; it.Safety.Allowed &amp;&amp; it.Candidate.Type == core.TargetFile </span><span class="cov0" title="0">{
                        eligibleBytes += it.Candidate.SizeBytes
                }</span>
        }

        <span class="cov0" title="0">if runMode == core.ModeExecute </span><span class="cov0" title="0">{
                fmt.Printf("StorageSage (EXECUTE PIPELINE)\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("StorageSage (DRY PIPELINE)\n")
        }</span>

        <span class="cov0" title="0">fmt.Printf("roots: %v\n", roots)
        fmt.Printf("candidates: %d\n", total)
        fmt.Printf("policy allowed: %d\n", policyAllowed)
        fmt.Printf("safety allowed: %d\n", safetyAllowed)
        fmt.Printf("eligible bytes (policy+safe): %d\n", eligibleBytes)
        fmt.Printf("safety blocked: %d\n", total-safetyAllowed)
        if len(reasonCounts) &gt; 0 </span><span class="cov0" title="0">{
                keys := make([]string, 0, len(reasonCounts))
                for k := range reasonCounts </span><span class="cov0" title="0">{
                        keys = append(keys, k)
                }</span>
                <span class="cov0" title="0">sort.Strings(keys)
                fmt.Println("safety reasons:")
                for _, k := range keys </span><span class="cov0" title="0">{
                        fmt.Printf("  - %s: %d\n", k, reasonCounts[k])
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }
        <span class="cov0" title="0">fmt.Println()</span>
}

// buildPolicy constructs a composite policy from configuration.
func buildPolicy(cfg config.PolicyConfig, log logger.Logger) core.Policy <span class="cov0" title="0">{
        // Start with age policy
        var pol core.Policy = policy.NewAgePolicy(cfg.MinAgeDays)

        // If additional filters are specified, build a composite policy
        var additionalPolicies []core.Policy
        if cfg.MinSizeMB &gt; 0 </span><span class="cov0" title="0">{
                additionalPolicies = append(additionalPolicies, policy.NewSizePolicy(cfg.MinSizeMB))
        }</span>
        <span class="cov0" title="0">if len(cfg.Extensions) &gt; 0 </span><span class="cov0" title="0">{
                additionalPolicies = append(additionalPolicies, policy.NewExtensionPolicy(cfg.Extensions))
        }</span>

        // Combine with AND: must match age AND any additional filters
        <span class="cov0" title="0">if len(additionalPolicies) &gt; 0 </span><span class="cov0" title="0">{
                allPolicies := append([]core.Policy{pol}, additionalPolicies...)
                pol = policy.NewCompositePolicy(policy.ModeAnd, allPolicies...)
        }</span>

        // Add exclusion policy (must NOT match any exclusion pattern)
        <span class="cov0" title="0">if len(cfg.Exclusions) &gt; 0 </span><span class="cov0" title="0">{
                exclusionPolicy := policy.NewExclusionPolicy(cfg.Exclusions)
                pol = policy.NewCompositePolicy(policy.ModeAnd, pol, exclusionPolicy)
                log.Debug("exclusion patterns active", logger.F("patterns", cfg.Exclusions))
        }</span>

        <span class="cov0" title="0">return pol</span>
}

// sortPlan orders plan items: allowed+safe first, then by score, size, modtime, path.
func sortPlan(plan []core.PlanItem) <span class="cov0" title="0">{
        sort.SliceStable(plan, func(i, j int) bool </span><span class="cov0" title="0">{
                a := plan[i]
                b := plan[j]

                aOK := a.Decision.Allow &amp;&amp; a.Safety.Allowed
                bOK := b.Decision.Allow &amp;&amp; b.Safety.Allowed
                if aOK != bOK </span><span class="cov0" title="0">{
                        return aOK
                }</span>

                <span class="cov0" title="0">if a.Decision.Score != b.Decision.Score </span><span class="cov0" title="0">{
                        return a.Decision.Score &gt; b.Decision.Score
                }</span>
                <span class="cov0" title="0">if a.Candidate.SizeBytes != b.Candidate.SizeBytes </span><span class="cov0" title="0">{
                        return a.Candidate.SizeBytes &gt; b.Candidate.SizeBytes
                }</span>
                <span class="cov0" title="0">if !a.Candidate.ModTime.Equal(b.Candidate.ModTime) </span><span class="cov0" title="0">{
                        return a.Candidate.ModTime.Before(b.Candidate.ModTime)
                }</span>
                <span class="cov0" title="0">return a.Candidate.Path &lt; b.Candidate.Path</span>
        })
}

// createNotifier creates a notifier from configuration.
func createNotifier(cfg config.NotificationsConfig, log logger.Logger) notifier.Notifier <span class="cov0" title="0">{
        if len(cfg.Webhooks) == 0 </span><span class="cov0" title="0">{
                return &amp;notifier.NoopNotifier{}
        }</span>

        <span class="cov0" title="0">multi := notifier.NewMultiNotifier()
        for _, whCfg := range cfg.Webhooks </span><span class="cov0" title="0">{
                // Convert config events to notifier events
                events := make([]notifier.EventType, 0, len(whCfg.Events))
                for _, e := range whCfg.Events </span><span class="cov0" title="0">{
                        events = append(events, notifier.EventType(e))
                }</span>

                <span class="cov0" title="0">wh := notifier.NewWebhook(notifier.WebhookConfig{
                        URL:     whCfg.URL,
                        Headers: whCfg.Headers,
                        Events:  events,
                        Timeout: whCfg.Timeout,
                })
                multi.Add(wh)

                log.Info("webhook configured", logger.F("url", whCfg.URL))</span>
        }

        <span class="cov0" title="0">return multi</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package auditor

import (
        "context"
        "encoding/json"
        "os"
        "sync"
        "time"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

// JSONLAuditor appends one JSON object per line (JSONL).
// It is simple, durable, and easy to ingest later.
type JSONLAuditor struct {
        mu       sync.Mutex
        f        *os.File
        writeErr error // first write error encountered (fail-open: doesn't block operations)
}

func NewJSONL(path string) (*JSONLAuditor, error) <span class="cov8" title="1">{
        f, err := os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o600)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;JSONLAuditor{f: f}, nil</span>
}

func (a *JSONLAuditor) Close() error <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()
        if a.f == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">err := a.f.Close()
        a.f = nil
        return err</span>
}

// Err returns the first write error encountered, if any.
// Auditing is fail-open: errors don't block operations, but callers can check afterward.
func (a *JSONLAuditor) Err() error <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()
        return a.writeErr
}</span>

func (a *JSONLAuditor) Record(_ context.Context, evt core.AuditEvent) <span class="cov8" title="1">{
        // Make sure Time is always set.
        if evt.Time.IsZero() </span><span class="cov8" title="1">{
                evt.Time = time.Now()
        }</span>

        <span class="cov8" title="1">a.mu.Lock()
        defer a.mu.Unlock()
        if a.f == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Keep Err JSON-safe (string).
        <span class="cov8" title="1">type wire struct {
                Time   time.Time      `json:"time"`
                Level  string         `json:"level"`
                Action string         `json:"action"`
                Path   string         `json:"path"`
                Fields map[string]any `json:"fields,omitempty"`
                Err    string         `json:"err,omitempty"`
        }

        w := wire{
                Time:   evt.Time,
                Level:  evt.Level,
                Action: evt.Action,
                Path:   evt.Path,
                Fields: evt.Fields,
        }
        if evt.Err != nil </span><span class="cov8" title="1">{
                w.Err = evt.Err.Error()
        }</span>

        <span class="cov8" title="1">b, err := json.Marshal(w)
        if err != nil </span><span class="cov0" title="0">{
                if a.writeErr == nil </span><span class="cov0" title="0">{
                        a.writeErr = err
                }</span>
                <span class="cov0" title="0">return</span>
        }
        <span class="cov8" title="1">if _, err := a.f.Write(append(b, '\n')); err != nil &amp;&amp; a.writeErr == nil </span><span class="cov0" title="0">{
                a.writeErr = err
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package auditor

import (
        "context"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

// Multi writes audit events to multiple auditors.
type Multi struct {
        auditors []core.Auditor
}

// NewMulti creates an auditor that writes to multiple backends.
func NewMulti(auditors ...core.Auditor) *Multi <span class="cov8" title="1">{
        return &amp;Multi{auditors: auditors}
}</span>

// Record writes the event to all configured auditors.
func (m *Multi) Record(ctx context.Context, evt core.AuditEvent) <span class="cov8" title="1">{
        for _, a := range m.auditors </span><span class="cov8" title="1">{
                a.Record(ctx, evt)
        }</span>
}

// Ensure Multi implements core.Auditor
var _ core.Auditor = (*Multi)(nil)
</pre>
		
		<pre class="file" id="file3" style="display: none">package auditor

import (
        "bufio"
        "context"
        "encoding/json"
        "os"
        "sync"
        "time"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

type NDJSON struct {
        mu       sync.Mutex
        f        *os.File
        w        *bufio.Writer
        writeErr error // first write error encountered (fail-open: doesn't block operations)
}

func NewNDJSON(path string) (*NDJSON, error) <span class="cov0" title="0">{
        f, err := os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0o600)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;NDJSON{f: f, w: bufio.NewWriterSize(f, 64*1024)}, nil</span>
}

func (a *NDJSON) Close() error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()
        _ = a.w.Flush()
        return a.f.Close()
}</span>

// Err returns the first write error encountered, if any.
// Auditing is fail-open: errors don't block operations, but callers can check afterward.
func (a *NDJSON) Err() error <span class="cov0" title="0">{
        a.mu.Lock()
        defer a.mu.Unlock()
        return a.writeErr
}</span>

func (a *NDJSON) Record(_ context.Context, evt core.AuditEvent) <span class="cov0" title="0">{
        // Make sure Time is always set.
        if evt.Time.IsZero() </span><span class="cov0" title="0">{
                evt.Time = time.Now()
        }</span>

        <span class="cov0" title="0">a.mu.Lock()
        defer a.mu.Unlock()

        enc := json.NewEncoder(a.w)
        if err := enc.Encode(evt); err != nil &amp;&amp; a.writeErr == nil </span><span class="cov0" title="0">{
                a.writeErr = err
        }</span>
        <span class="cov0" title="0">if err := a.w.Flush(); err != nil &amp;&amp; a.writeErr == nil </span><span class="cov0" title="0">{
                a.writeErr = err
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package auditor

import (
        "context"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "sync"
        "time"

        _ "modernc.org/sqlite" // SQLite driver registration

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

// SQLiteAuditor persists audit events to a SQLite database.
// Designed for government/rugged systems requiring:
// - Offline operation (no external dependencies)
// - Long-term log retention
// - Tamper detection via row checksums
// - Simple backup (single file)
type SQLiteAuditor struct {
        db        *sql.DB
        mu        sync.Mutex
        retention time.Duration // 0 = keep forever
}

// SQLiteConfig configures the SQLite auditor.
type SQLiteConfig struct {
        Path      string        // Database file path
        Retention time.Duration // How long to keep logs (0 = forever)
}

// AuditRecord represents a single audit log entry.
type AuditRecord struct {
        ID         int64     `json:"id"`
        Timestamp  time.Time `json:"timestamp"`
        Level      string    `json:"level"`
        Action     string    `json:"action"`
        Path       string    `json:"path,omitempty"`
        Mode       string    `json:"mode,omitempty"`
        Decision   string    `json:"decision,omitempty"`
        Reason     string    `json:"reason,omitempty"`
        Score      int       `json:"score,omitempty"`
        BytesFreed int64     `json:"bytes_freed,omitempty"`
        Error      string    `json:"error,omitempty"`
        Fields     string    `json:"fields,omitempty"` // JSON-encoded extra fields
        Checksum   string    `json:"checksum"`
}

// NewSQLite creates a new SQLite auditor.
func NewSQLite(cfg SQLiteConfig) (*SQLiteAuditor, error) <span class="cov8" title="1">{
        db, err := sql.Open("sqlite", cfg.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("open database: %w", err)
        }</span>

        // Enable WAL mode for better concurrent performance
        <span class="cov8" title="1">if _, err := db.Exec("PRAGMA journal_mode=WAL"); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("enable WAL mode: %w", err)
        }</span>

        // Enable foreign keys
        <span class="cov8" title="1">if _, err := db.Exec("PRAGMA foreign_keys=ON"); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("enable foreign keys: %w", err)
        }</span>

        // Create schema
        <span class="cov8" title="1">if err := createSchema(db); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("create schema: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;SQLiteAuditor{
                db:        db,
                retention: cfg.Retention,
        }, nil</span>
}

func createSchema(db *sql.DB) error <span class="cov8" title="1">{
        schema := `
        CREATE TABLE IF NOT EXISTS audit_log (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                timestamp TEXT NOT NULL,
                level TEXT NOT NULL,
                action TEXT NOT NULL,
                path TEXT,
                mode TEXT,
                decision TEXT,
                reason TEXT,
                score INTEGER,
                bytes_freed INTEGER,
                error TEXT,
                fields TEXT,
                checksum TEXT NOT NULL
        );

        CREATE INDEX IF NOT EXISTS idx_audit_timestamp ON audit_log(timestamp);
        CREATE INDEX IF NOT EXISTS idx_audit_action ON audit_log(action);
        CREATE INDEX IF NOT EXISTS idx_audit_path ON audit_log(path);
        CREATE INDEX IF NOT EXISTS idx_audit_level ON audit_log(level);

        -- Metadata table for database integrity
        CREATE TABLE IF NOT EXISTS audit_meta (
                key TEXT PRIMARY KEY,
                value TEXT NOT NULL
        );
        `

        if _, err := db.Exec(schema); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Set creation timestamp if not exists
        <span class="cov8" title="1">_, err := db.Exec(`
                INSERT OR IGNORE INTO audit_meta (key, value)
                VALUES ('created_at', ?)
        `, time.Now().UTC().Format(time.RFC3339))

        return err</span>
}

// Record persists an audit event to the database.
func (a *SQLiteAuditor) Record(ctx context.Context, evt core.AuditEvent) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()

        // Extract common fields
        var path, mode, decision, reason, errStr string
        var score int
        var bytesFreed int64

        if evt.Path != "" </span><span class="cov8" title="1">{
                path = evt.Path
        }</span>
        <span class="cov8" title="1">if evt.Err != nil </span><span class="cov8" title="1">{
                errStr = evt.Err.Error()
        }</span>

        // Extract from Fields map
        <span class="cov8" title="1">if evt.Fields != nil </span><span class="cov8" title="1">{
                if v, ok := evt.Fields["mode"].(string); ok </span><span class="cov0" title="0">{
                        mode = v
                }</span>
                <span class="cov8" title="1">if v, ok := evt.Fields["decision"].(string); ok </span><span class="cov8" title="1">{
                        decision = v
                }</span>
                <span class="cov8" title="1">if v, ok := evt.Fields["reason"].(string); ok </span><span class="cov8" title="1">{
                        reason = v
                }</span>
                <span class="cov8" title="1">if v, ok := evt.Fields["score"].(int); ok </span><span class="cov8" title="1">{
                        score = v
                }</span>
                <span class="cov8" title="1">if v, ok := evt.Fields["bytes_freed"].(int64); ok </span><span class="cov8" title="1">{
                        bytesFreed = v
                }</span>
        }

        // Serialize remaining fields as JSON
        <span class="cov8" title="1">fieldsJSON := ""
        if len(evt.Fields) &gt; 0 </span><span class="cov8" title="1">{
                if b, err := json.Marshal(evt.Fields); err == nil </span><span class="cov8" title="1">{
                        fieldsJSON = string(b)
                }</span>
        }

        // Generate row checksum for tamper detection
        <span class="cov8" title="1">checksum := a.computeChecksum(evt.Time, evt.Level, evt.Action, path, mode, decision, reason, score, bytesFreed, errStr, fieldsJSON)

        // Insert record
        _, err := a.db.ExecContext(ctx, `
                INSERT INTO audit_log (timestamp, level, action, path, mode, decision, reason, score, bytes_freed, error, fields, checksum)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `,
                evt.Time.UTC().Format(time.RFC3339Nano),
                evt.Level,
                evt.Action,
                path,
                mode,
                decision,
                reason,
                score,
                bytesFreed,
                errStr,
                fieldsJSON,
                checksum,
        )

        if err != nil </span><span class="cov0" title="0">{
                // Log error but don't fail - audit should not break operations
                fmt.Printf("audit write error: %v\n", err)
        }</span>
}

// computeChecksum generates a SHA256 checksum of the record data.
// This allows detection of any tampering with historical records.
func (a *SQLiteAuditor) computeChecksum(ts time.Time, level, action, path, mode, decision, reason string, score int, bytesFreed int64, errStr, fields string) string <span class="cov8" title="1">{
        data := fmt.Sprintf("%s|%s|%s|%s|%s|%s|%s|%d|%d|%s|%s",
                ts.UTC().Format(time.RFC3339Nano),
                level, action, path, mode, decision, reason, score, bytesFreed, errStr, fields)

        hash := sha256.Sum256([]byte(data))
        return hex.EncodeToString(hash[:])
}</span>

// Close closes the database connection.
func (a *SQLiteAuditor) Close() error <span class="cov8" title="1">{
        return a.db.Close()
}</span>

// Query retrieves audit records matching the given filters.
func (a *SQLiteAuditor) Query(ctx context.Context, filter QueryFilter) ([]AuditRecord, error) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()

        query := `SELECT id, timestamp, level, action, path, mode, decision, reason, score, bytes_freed, error, fields, checksum FROM audit_log WHERE 1=1`
        args := []interface{}{}

        if !filter.Since.IsZero() </span><span class="cov0" title="0">{
                query += " AND timestamp &gt;= ?"
                args = append(args, filter.Since.UTC().Format(time.RFC3339Nano))
        }</span>
        <span class="cov8" title="1">if !filter.Until.IsZero() </span><span class="cov0" title="0">{
                query += " AND timestamp &lt;= ?"
                args = append(args, filter.Until.UTC().Format(time.RFC3339Nano))
        }</span>
        <span class="cov8" title="1">if filter.Action != "" </span><span class="cov8" title="1">{
                query += " AND action = ?"
                args = append(args, filter.Action)
        }</span>
        <span class="cov8" title="1">if filter.Level != "" </span><span class="cov8" title="1">{
                query += " AND level = ?"
                args = append(args, filter.Level)
        }</span>
        <span class="cov8" title="1">if filter.Path != "" </span><span class="cov8" title="1">{
                query += " AND path LIKE ?"
                args = append(args, "%"+filter.Path+"%")
        }</span>

        <span class="cov8" title="1">query += " ORDER BY timestamp DESC"

        if filter.Limit &gt; 0 </span><span class="cov8" title="1">{
                query += " LIMIT ?"
                args = append(args, filter.Limit)
        }</span>

        <span class="cov8" title="1">rows, err := a.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query audit log: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var records []AuditRecord
        for rows.Next() </span><span class="cov8" title="1">{
                var r AuditRecord
                var ts string
                var path, mode, decision, reason, errStr, fields sql.NullString
                var score sql.NullInt64
                var bytesFreed sql.NullInt64

                err := rows.Scan(&amp;r.ID, &amp;ts, &amp;r.Level, &amp;r.Action, &amp;path, &amp;mode, &amp;decision, &amp;reason, &amp;score, &amp;bytesFreed, &amp;errStr, &amp;fields, &amp;r.Checksum)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan row: %w", err)
                }</span>

                <span class="cov8" title="1">r.Timestamp, _ = time.Parse(time.RFC3339Nano, ts)
                r.Path = path.String
                r.Mode = mode.String
                r.Decision = decision.String
                r.Reason = reason.String
                r.Score = int(score.Int64)
                r.BytesFreed = bytesFreed.Int64
                r.Error = errStr.String
                r.Fields = fields.String

                records = append(records, r)</span>
        }

        <span class="cov8" title="1">return records, rows.Err()</span>
}

// QueryFilter specifies filters for querying audit records.
type QueryFilter struct {
        Since  time.Time
        Until  time.Time
        Action string // plan, delete, error, etc.
        Level  string // info, warn, error
        Path   string // partial match
        Limit  int
}

// VerifyIntegrity checks all records for tampering.
// Returns list of record IDs with invalid checksums.
func (a *SQLiteAuditor) VerifyIntegrity(ctx context.Context) ([]int64, error) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()

        rows, err := a.db.QueryContext(ctx, `
                SELECT id, timestamp, level, action, path, mode, decision, reason, score, bytes_freed, error, fields, checksum
                FROM audit_log ORDER BY id
        `)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("query for integrity check: %w", err)
        }</span>
        <span class="cov8" title="1">defer rows.Close()

        var tampered []int64
        for rows.Next() </span><span class="cov8" title="1">{
                var id int64
                var ts, level, action, checksum string
                var path, mode, decision, reason, errStr, fields sql.NullString
                var score, bytesFreed sql.NullInt64

                err := rows.Scan(&amp;id, &amp;ts, &amp;level, &amp;action, &amp;path, &amp;mode, &amp;decision, &amp;reason, &amp;score, &amp;bytesFreed, &amp;errStr, &amp;fields, &amp;checksum)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("scan row: %w", err)
                }</span>

                <span class="cov8" title="1">timestamp, _ := time.Parse(time.RFC3339Nano, ts)
                expected := a.computeChecksum(timestamp, level, action, path.String, mode.String, decision.String, reason.String, int(score.Int64), bytesFreed.Int64, errStr.String, fields.String)

                if checksum != expected </span><span class="cov8" title="1">{
                        tampered = append(tampered, id)
                }</span>
        }

        <span class="cov8" title="1">return tampered, rows.Err()</span>
}

// Stats returns summary statistics from the audit log.
func (a *SQLiteAuditor) Stats(ctx context.Context) (*AuditStats, error) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()

        stats := &amp;AuditStats{}

        // Total records
        err := a.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM audit_log").Scan(&amp;stats.TotalRecords)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Date range
        <span class="cov8" title="1">var firstTS, lastTS sql.NullString
        if err := a.db.QueryRowContext(ctx, "SELECT MIN(timestamp), MAX(timestamp) FROM audit_log").Scan(&amp;firstTS, &amp;lastTS); err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if firstTS.Valid </span><span class="cov8" title="1">{
                stats.FirstRecord, _ = time.Parse(time.RFC3339Nano, firstTS.String)
        }</span>
        <span class="cov8" title="1">if lastTS.Valid </span><span class="cov8" title="1">{
                stats.LastRecord, _ = time.Parse(time.RFC3339Nano, lastTS.String)
        }</span>

        // Total bytes freed (execute events with bytes_freed &gt; 0 indicate actual deletions)
        <span class="cov8" title="1">var totalBytes sql.NullInt64
        if err := a.db.QueryRowContext(ctx, "SELECT SUM(bytes_freed) FROM audit_log WHERE action = 'execute' AND bytes_freed &gt; 0").Scan(&amp;totalBytes); err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">stats.TotalBytesFreed = totalBytes.Int64

        // Files deleted (count execute events where bytes were freed)
        if err := a.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM audit_log WHERE action = 'execute' AND bytes_freed &gt; 0").Scan(&amp;stats.FilesDeleted); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Errors
        <span class="cov8" title="1">if err := a.db.QueryRowContext(ctx, "SELECT COUNT(*) FROM audit_log WHERE level = 'error'").Scan(&amp;stats.Errors); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return stats, nil</span>
}

// AuditStats contains summary statistics.
type AuditStats struct {
        TotalRecords    int64
        FirstRecord     time.Time
        LastRecord      time.Time
        TotalBytesFreed int64
        FilesDeleted    int64
        Errors          int64
}

// Prune removes records older than the retention period.
func (a *SQLiteAuditor) Prune(ctx context.Context, olderThan time.Duration) (int64, error) <span class="cov8" title="1">{
        a.mu.Lock()
        defer a.mu.Unlock()

        cutoff := time.Now().Add(-olderThan).UTC().Format(time.RFC3339Nano)
        result, err := a.db.ExecContext(ctx, "DELETE FROM audit_log WHERE timestamp &lt; ?", cutoff)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">return result.RowsAffected()</span>
}

// Export writes all records to JSON format.
func (a *SQLiteAuditor) Export(ctx context.Context, since time.Time) ([]byte, error) <span class="cov0" title="0">{
        records, err := a.Query(ctx, QueryFilter{Since: since, Limit: 0})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return json.MarshalIndent(records, "", "  ")</span>
}

// Ensure SQLiteAuditor implements core.Auditor
var _ core.Auditor = (*SQLiteAuditor)(nil)
</pre>
		
		<pre class="file" id="file5" style="display: none">package auth

import (
        "bufio"
        "crypto/rand"
        "crypto/sha256"
        "crypto/subtle"
        "encoding/hex"
        "fmt"
        "net/http"
        "os"
        "strings"
        "sync"

        "github.com/ChrisB0-2/storage-sage/internal/logger"
)

const (
        // APIKeyPrefix is the required prefix for API keys.
        APIKeyPrefix = "ss_"
        // APIKeyLength is the total length of a valid API key (prefix + 32 hex chars).
        APIKeyLength = 3 + 32 // "ss_" + 32 hex chars

        // DefaultHeaderName is the default header for API key authentication.
        DefaultHeaderName = "X-API-Key"
)

// APIKeyEntry represents a stored API key with its metadata.
type APIKeyEntry struct {
        // Hash is the SHA256 hash of the key (hex-encoded).
        Hash string
        // Name is a human-readable name for this key.
        Name string
        // Role is the authorization level for this key.
        Role Role
}

// APIKeyAuthenticator authenticates requests using API keys.
type APIKeyAuthenticator struct {
        mu         sync.RWMutex
        keys       map[string]APIKeyEntry // hash -&gt; entry
        headerName string
        log        logger.Logger
}

// APIKeyConfig configures the API key authenticator.
type APIKeyConfig struct {
        // Enabled enables API key authentication.
        Enabled bool
        // Key is a single API key (plaintext). For simple setups.
        Key string
        // KeyEnv is the name of an environment variable containing the API key.
        KeyEnv string
        // KeysFile is the path to a file containing multiple keys.
        // Format: one key per line, optionally with "key:role:name" format.
        KeysFile string
        // HeaderName is the header name for API key authentication (default: X-API-Key).
        HeaderName string
        // DefaultRole is the role assigned to keys without an explicit role (default: Operator).
        DefaultRole Role
}

// NewAPIKeyAuthenticator creates a new API key authenticator from configuration.
func NewAPIKeyAuthenticator(cfg APIKeyConfig, log logger.Logger) (*APIKeyAuthenticator, error) <span class="cov8" title="1">{
        if log == nil </span><span class="cov8" title="1">{
                log = logger.NewNop()
        }</span>

        <span class="cov8" title="1">headerName := cfg.HeaderName
        if headerName == "" </span><span class="cov8" title="1">{
                headerName = DefaultHeaderName
        }</span>

        <span class="cov8" title="1">defaultRole := cfg.DefaultRole
        if defaultRole == RoleNone </span><span class="cov8" title="1">{
                defaultRole = RoleOperator
        }</span>

        <span class="cov8" title="1">a := &amp;APIKeyAuthenticator{
                keys:       make(map[string]APIKeyEntry),
                headerName: headerName,
                log:        log,
        }

        // Load key from direct configuration
        if cfg.Key != "" </span><span class="cov8" title="1">{
                if err := a.addKey(cfg.Key, "config", defaultRole); err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("invalid key in config: %w", err)
                }</span>
        }

        // Load key from environment variable
        <span class="cov8" title="1">if cfg.KeyEnv != "" </span><span class="cov8" title="1">{
                if key := os.Getenv(cfg.KeyEnv); key != "" </span><span class="cov8" title="1">{
                        if err := a.addKey(key, "env:"+cfg.KeyEnv, defaultRole); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid key in env %s: %w", cfg.KeyEnv, err)
                        }</span>
                }
        }

        // Load keys from file
        <span class="cov8" title="1">if cfg.KeysFile != "" </span><span class="cov8" title="1">{
                if err := a.loadKeysFile(cfg.KeysFile, defaultRole); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to load keys file: %w", err)
                }</span>
        }

        <span class="cov8" title="1">if len(a.keys) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no API keys configured")
        }</span>

        <span class="cov8" title="1">log.Info("API key authenticator initialized", logger.F("key_count", len(a.keys)))

        return a, nil</span>
}

// Authenticate implements Authenticator.
func (a *APIKeyAuthenticator) Authenticate(r *http.Request) (*Identity, error) <span class="cov8" title="1">{
        key := a.extractKey(r)
        if key == "" </span><span class="cov8" title="1">{
                return nil, nil // No credentials provided
        }</span>

        // Validate key format
        <span class="cov8" title="1">if !ValidateKeyFormat(key) </span><span class="cov8" title="1">{
                return nil, ErrInvalidKeyFormat
        }</span>

        // Hash the key for lookup
        <span class="cov8" title="1">hash := HashKey(key)

        a.mu.RLock()
        entry, ok := a.keys[hash]
        a.mu.RUnlock()

        if !ok </span><span class="cov8" title="1">{
                return nil, ErrInvalidCredentials
        }</span>

        <span class="cov8" title="1">return &amp;Identity{
                ID:       hash[:16], // First 16 chars of hash as ID
                Name:     entry.Name,
                Role:     entry.Role,
                AuthType: "apikey",
        }, nil</span>
}

// extractKey extracts the API key from the request.
// Checks X-API-Key header first, then Authorization: Bearer.
func (a *APIKeyAuthenticator) extractKey(r *http.Request) string <span class="cov8" title="1">{
        // Check custom header first
        if key := r.Header.Get(a.headerName); key != "" </span><span class="cov8" title="1">{
                return key
        }</span>

        // Check Authorization header with Bearer scheme
        <span class="cov8" title="1">auth := r.Header.Get("Authorization")
        if strings.HasPrefix(auth, "Bearer ") </span><span class="cov8" title="1">{
                return strings.TrimPrefix(auth, "Bearer ")
        }</span>

        <span class="cov8" title="1">return ""</span>
}

// addKey adds a key to the authenticator.
func (a *APIKeyAuthenticator) addKey(key, name string, role Role) error <span class="cov8" title="1">{
        if !ValidateKeyFormat(key) </span><span class="cov8" title="1">{
                return ErrInvalidKeyFormat
        }</span>

        <span class="cov8" title="1">hash := HashKey(key)

        a.mu.Lock()
        defer a.mu.Unlock()

        a.keys[hash] = APIKeyEntry{
                Hash: hash,
                Name: name,
                Role: role,
        }

        return nil</span>
}

// loadKeysFile loads keys from a file.
// File format: one entry per line
// Simple format: ss_&lt;hex&gt; (uses default role)
// Extended format: ss_&lt;hex&gt;:role:name
func (a *APIKeyAuthenticator) loadKeysFile(path string, defaultRole Role) error <span class="cov8" title="1">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        scanner := bufio.NewScanner(f)
        lineNum := 0

        for scanner.Scan() </span><span class="cov8" title="1">{
                lineNum++
                line := strings.TrimSpace(scanner.Text())

                // Skip empty lines and comments
                if line == "" || strings.HasPrefix(line, "#") </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Parse line
                <span class="cov8" title="1">parts := strings.SplitN(line, ":", 3)
                key := parts[0]
                role := defaultRole
                name := fmt.Sprintf("file:%s:%d", path, lineNum)

                if len(parts) &gt;= 2 &amp;&amp; parts[1] != "" </span><span class="cov8" title="1">{
                        r, err := ParseRole(parts[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("line %d: %w", lineNum, err)
                        }</span>
                        <span class="cov8" title="1">role = r</span>
                }

                <span class="cov8" title="1">if len(parts) &gt;= 3 &amp;&amp; parts[2] != "" </span><span class="cov8" title="1">{
                        name = parts[2]
                }</span>

                <span class="cov8" title="1">if err := a.addKey(key, name, role); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("line %d: %w", lineNum, err)
                }</span>
        }

        <span class="cov8" title="1">return scanner.Err()</span>
}

// ValidateKeyFormat checks if a key has the correct format.
// Valid format: "ss_" prefix followed by exactly 32 hex characters.
func ValidateKeyFormat(key string) bool <span class="cov8" title="1">{
        if len(key) != APIKeyLength </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if !strings.HasPrefix(key, APIKeyPrefix) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check that the rest is valid hex
        <span class="cov8" title="1">hexPart := key[len(APIKeyPrefix):]
        for _, c := range hexPart </span><span class="cov8" title="1">{
                if !isHexChar(c) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// isHexChar returns true if c is a valid hexadecimal character.
func isHexChar(c rune) bool <span class="cov8" title="1">{
        return (c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F')
}</span>

// HashKey computes the SHA256 hash of a key and returns it as a hex string.
func HashKey(key string) string <span class="cov8" title="1">{
        h := sha256.Sum256([]byte(key))
        return hex.EncodeToString(h[:])
}</span>

// SecureCompare performs a constant-time comparison of two strings.
// Returns true if they are equal.
func SecureCompare(a, b string) bool <span class="cov8" title="1">{
        return subtle.ConstantTimeCompare([]byte(a), []byte(b)) == 1
}</span>

// GenerateAPIKey generates a new cryptographically secure random API key.
func GenerateAPIKey() (string, error) <span class="cov8" title="1">{
        bytes := make([]byte, 16)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate random bytes: %w", err)
        }</span>
        <span class="cov8" title="1">return APIKeyPrefix + hex.EncodeToString(bytes), nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package auth provides authentication and authorization for storage-sage's HTTP API.
package auth

import (
        "context"
        "errors"
        "net/http"
)

// Role represents the authorization level of an identity.
type Role int

const (
        // RoleNone has no access (used for public paths).
        RoleNone Role = iota
        // RoleViewer can read status and audit data.
        RoleViewer
        // RoleOperator can trigger cleanup runs.
        RoleOperator
        // RoleAdmin has full access (reserved for future admin endpoints).
        RoleAdmin
)

// String returns the string representation of the role.
func (r Role) String() string <span class="cov8" title="1">{
        switch r </span>{
        case RoleNone:<span class="cov8" title="1">
                return "none"</span>
        case RoleViewer:<span class="cov8" title="1">
                return "viewer"</span>
        case RoleOperator:<span class="cov8" title="1">
                return "operator"</span>
        case RoleAdmin:<span class="cov8" title="1">
                return "admin"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// ParseRole parses a role string into a Role.
func ParseRole(s string) (Role, error) <span class="cov8" title="1">{
        switch s </span>{
        case "none", "":<span class="cov8" title="1">
                return RoleNone, nil</span>
        case "viewer":<span class="cov8" title="1">
                return RoleViewer, nil</span>
        case "operator":<span class="cov8" title="1">
                return RoleOperator, nil</span>
        case "admin":<span class="cov8" title="1">
                return RoleAdmin, nil</span>
        default:<span class="cov8" title="1">
                return RoleNone, errors.New("unknown role: " + s)</span>
        }
}

// Identity represents an authenticated entity.
type Identity struct {
        // ID is a unique identifier for this identity (e.g., key ID, user ID).
        ID string
        // Name is a human-readable name for this identity.
        Name string
        // Role is the authorization level of this identity.
        Role Role
        // AuthType indicates how this identity was authenticated (e.g., "apikey", "oidc", "mtls").
        AuthType string
}

// contextKey is a private type for context keys to avoid collisions.
type contextKey int

const (
        // ContextKeyIdentity is the context key for storing Identity.
        ContextKeyIdentity contextKey = iota
)

// IdentityFromContext retrieves the Identity from the request context.
// Returns nil if no identity is present.
func IdentityFromContext(ctx context.Context) *Identity <span class="cov8" title="1">{
        if id, ok := ctx.Value(ContextKeyIdentity).(*Identity); ok </span><span class="cov8" title="1">{
                return id
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ContextWithIdentity returns a new context with the identity stored.
func ContextWithIdentity(ctx context.Context, id *Identity) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, ContextKeyIdentity, id)
}</span>

// Authenticator validates credentials from an HTTP request and returns an identity.
type Authenticator interface {
        // Authenticate attempts to authenticate the request.
        // Returns the identity if authentication succeeds, nil if no credentials were provided,
        // or an error if credentials were provided but invalid.
        Authenticate(r *http.Request) (*Identity, error)
}

// Common authentication errors.
var (
        // ErrNoCredentials indicates no credentials were provided.
        ErrNoCredentials = errors.New("no credentials provided")
        // ErrInvalidCredentials indicates the provided credentials were invalid.
        ErrInvalidCredentials = errors.New("invalid credentials")
        // ErrInvalidKeyFormat indicates the API key format is invalid.
        ErrInvalidKeyFormat = errors.New("invalid API key format")
)
</pre>
		
		<pre class="file" id="file7" style="display: none">package auth

import (
        "encoding/json"
        "net/http"

        "github.com/ChrisB0-2/storage-sage/internal/logger"
)

// Middleware provides HTTP middleware for authentication.
type Middleware struct {
        authenticators []Authenticator
        publicPaths    map[string]bool
        log            logger.Logger
}

// NewMiddleware creates a new authentication middleware.
func NewMiddleware(log logger.Logger, authenticators []Authenticator, publicPaths []string) *Middleware <span class="cov8" title="1">{
        if log == nil </span><span class="cov8" title="1">{
                log = logger.NewNop()
        }</span>

        <span class="cov8" title="1">pathMap := make(map[string]bool, len(publicPaths))
        for _, p := range publicPaths </span><span class="cov8" title="1">{
                pathMap[p] = true
        }</span>

        <span class="cov8" title="1">return &amp;Middleware{
                authenticators: authenticators,
                publicPaths:    pathMap,
                log:            log,
        }</span>
}

// Wrap returns an HTTP handler that enforces authentication.
func (m *Middleware) Wrap(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Skip authentication for public paths
                if m.publicPaths[r.URL.Path] </span><span class="cov8" title="1">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                // Try each authenticator in order
                <span class="cov8" title="1">for _, auth := range m.authenticators </span><span class="cov8" title="1">{
                        identity, err := auth.Authenticate(r)
                        if identity != nil </span><span class="cov8" title="1">{
                                // Authentication succeeded
                                m.log.Debug("request authenticated",
                                        logger.F("path", r.URL.Path),
                                        logger.F("identity", identity.Name),
                                        logger.F("role", identity.Role.String()),
                                        logger.F("auth_type", identity.AuthType),
                                )
                                ctx := ContextWithIdentity(r.Context(), identity)
                                next.ServeHTTP(w, r.WithContext(ctx))
                                return
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                // Credentials were provided but invalid
                                m.log.Warn("authentication failed",
                                        logger.F("path", r.URL.Path),
                                        logger.F("error", err.Error()),
                                        logger.F("remote_addr", r.RemoteAddr),
                                )
                                writeJSONError(w, http.StatusUnauthorized, "authentication failed: "+err.Error())
                                return
                        }</span>
                        // No credentials from this authenticator, try next
                }

                // No authenticator could authenticate the request
                <span class="cov8" title="1">m.log.Debug("no credentials provided",
                        logger.F("path", r.URL.Path),
                        logger.F("remote_addr", r.RemoteAddr),
                )
                writeJSONError(w, http.StatusUnauthorized, "authentication required")</span>
        })
}

// IsPublicPath returns true if the path is configured as public.
func (m *Middleware) IsPublicPath(path string) bool <span class="cov8" title="1">{
        return m.publicPaths[path]
}</span>

// writeJSONError writes a JSON error response.
func writeJSONError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)
        resp := map[string]string{"error": message}
        _ = json.NewEncoder(w).Encode(resp)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package auth

import (
        "net/http"
        "strings"

        "github.com/ChrisB0-2/storage-sage/internal/logger"
)

// Permission defines the required role for an endpoint.
type Permission struct {
        // PathPrefix is the URL path prefix this permission applies to.
        PathPrefix string
        // Method is the HTTP method (empty string matches all methods).
        Method string
        // MinRole is the minimum role required to access this endpoint.
        MinRole Role
}

// RBACMiddleware enforces role-based access control.
type RBACMiddleware struct {
        permissions []Permission
        log         logger.Logger
}

// NewRBACMiddleware creates a new RBAC middleware with the given permissions.
func NewRBACMiddleware(permissions []Permission, log logger.Logger) *RBACMiddleware <span class="cov8" title="1">{
        if log == nil </span><span class="cov8" title="1">{
                log = logger.NewNop()
        }</span>
        <span class="cov8" title="1">return &amp;RBACMiddleware{
                permissions: permissions,
                log:         log,
        }</span>
}

// DefaultPermissions returns the default permission set for storage-sage.
func DefaultPermissions() []Permission <span class="cov8" title="1">{
        return []Permission{
                // Health endpoint is public (handled by auth middleware public paths)
                // These are the role requirements for authenticated users

                // Read-only endpoints require Viewer role
                {PathPrefix: "/ready", Method: "GET", MinRole: RoleViewer},
                {PathPrefix: "/status", Method: "GET", MinRole: RoleViewer},
                {PathPrefix: "/api/config", Method: "GET", MinRole: RoleViewer},
                {PathPrefix: "/api/audit/", Method: "GET", MinRole: RoleViewer},

                // Trigger endpoint requires Operator role
                {PathPrefix: "/trigger", Method: "POST", MinRole: RoleOperator},

                // Static files (frontend) require Viewer role
                {PathPrefix: "/", Method: "GET", MinRole: RoleViewer},
        }
}</span>

// Wrap returns an HTTP handler that enforces role-based access control.
func (m *RBACMiddleware) Wrap(next http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                identity := IdentityFromContext(r.Context())

                // Find the matching permission
                perm := m.findPermission(r.URL.Path, r.Method)
                if perm == nil </span><span class="cov8" title="1">{
                        // No explicit permission defined - deny by default
                        m.log.Warn("no permission defined for endpoint",
                                logger.F("path", r.URL.Path),
                                logger.F("method", r.Method),
                        )
                        writeJSONError(w, http.StatusForbidden, "access denied")
                        return
                }</span>

                // Check if identity meets the minimum role requirement
                <span class="cov8" title="1">if identity == nil </span><span class="cov8" title="1">{
                        // This shouldn't happen if auth middleware ran first, but be safe
                        writeJSONError(w, http.StatusUnauthorized, "authentication required")
                        return
                }</span>

                <span class="cov8" title="1">if identity.Role &lt; perm.MinRole </span><span class="cov8" title="1">{
                        m.log.Warn("insufficient permissions",
                                logger.F("path", r.URL.Path),
                                logger.F("method", r.Method),
                                logger.F("identity", identity.Name),
                                logger.F("role", identity.Role.String()),
                                logger.F("required", perm.MinRole.String()),
                        )
                        writeJSONError(w, http.StatusForbidden, "insufficient permissions")
                        return
                }</span>

                // Access granted
                <span class="cov8" title="1">next.ServeHTTP(w, r)</span>
        })
}

// findPermission finds the permission that matches the given path and method.
// Returns nil if no matching permission is found.
func (m *RBACMiddleware) findPermission(path, method string) *Permission <span class="cov8" title="1">{
        // Find the most specific matching permission (longest prefix match)
        var bestMatch *Permission
        bestLen := -1

        for i := range m.permissions </span><span class="cov8" title="1">{
                p := &amp;m.permissions[i]

                // Check if path matches
                if !strings.HasPrefix(path, p.PathPrefix) </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Check if method matches (empty matches all)
                <span class="cov8" title="1">if p.Method != "" &amp;&amp; p.Method != method </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Use longest prefix match
                <span class="cov8" title="1">if len(p.PathPrefix) &gt; bestLen </span><span class="cov8" title="1">{
                        bestMatch = p
                        bestLen = len(p.PathPrefix)
                }</span>
        }

        <span class="cov8" title="1">return bestMatch</span>
}

// HasPermission checks if the given identity has permission for the path and method.
func (m *RBACMiddleware) HasPermission(identity *Identity, path, method string) bool <span class="cov8" title="1">{
        if identity == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">perm := m.findPermission(path, method)
        if perm == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return identity.Role &gt;= perm.MinRole</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "gopkg.in/yaml.v3"
)

// Config represents the complete configuration for storage-sage.
type Config struct {
        Version       int                 `yaml:"version" json:"version"`
        Scan          ScanConfig          `yaml:"scan" json:"scan"`
        Policy        PolicyConfig        `yaml:"policy" json:"policy"`
        Safety        SafetyConfig        `yaml:"safety" json:"safety"`
        Execution     ExecutionConfig     `yaml:"execution" json:"execution"`
        Logging       LoggingConfig       `yaml:"logging" json:"logging"`
        Daemon        DaemonConfig        `yaml:"daemon" json:"daemon"`
        Metrics       MetricsConfig       `yaml:"metrics" json:"metrics"`
        Notifications NotificationsConfig `yaml:"notifications,omitempty" json:"notifications,omitempty"`
        Auth          *AuthConfig         `yaml:"auth,omitempty" json:"auth,omitempty"`
}

// ScanConfig configures the filesystem scanning behavior.
type ScanConfig struct {
        Roots     []string `yaml:"roots" json:"roots"`
        Recursive bool     `yaml:"recursive" json:"recursive"`
        MaxDepth  int      `yaml:"max_depth" json:"max_depth"`
        // FollowSymlinks is accepted for configuration compatibility but intentionally
        // ignored. The scanner always uses lstat (not stat) to prevent symlink-based
        // attacks. Following symlinks would allow deletion of files outside allowed
        // roots via malicious symlink placement. This is a safety-critical design decision.
        FollowSymlinks bool `yaml:"follow_symlinks" json:"follow_symlinks"`
        IncludeDirs    bool `yaml:"include_dirs" json:"include_dirs"`
        IncludeFiles   bool `yaml:"include_files" json:"include_files"`
}

// PolicyConfig configures the file selection policy.
type PolicyConfig struct {
        MinAgeDays    int      `yaml:"min_age_days" json:"min_age_days"`
        MinSizeMB     int      `yaml:"min_size_mb" json:"min_size_mb"`
        Extensions    []string `yaml:"extensions" json:"extensions"`
        Exclusions    []string `yaml:"exclusions" json:"exclusions"`         // glob patterns to exclude from deletion
        CompositeMode string   `yaml:"composite_mode" json:"composite_mode"` // "and" or "or"
}

// SafetyConfig configures safety boundaries.
type SafetyConfig struct {
        ProtectedPaths       []string `yaml:"protected_paths" json:"protected_paths"`
        AllowDirDelete       bool     `yaml:"allow_dir_delete" json:"allow_dir_delete"`
        EnforceMountBoundary bool     `yaml:"enforce_mount_boundary" json:"enforce_mount_boundary"`
}

// ExecutionConfig configures execution behavior.
type ExecutionConfig struct {
        Mode        string        `yaml:"mode" json:"mode"` // "dry-run" or "execute"
        Timeout     time.Duration `yaml:"timeout" json:"timeout"`
        AuditPath   string        `yaml:"audit_path" json:"audit_path"`       // JSONL file path
        AuditDBPath string        `yaml:"audit_db_path" json:"audit_db_path"` // SQLite database path
        MaxItems    int           `yaml:"max_items" json:"max_items"`
        TrashPath   string        `yaml:"trash_path" json:"trash_path"`       // Soft-delete: move files here instead of deleting
        TrashMaxAge time.Duration `yaml:"trash_max_age" json:"trash_max_age"` // Max age before trash is permanently deleted (0 = keep forever)
}

// LoggingConfig configures logging behavior.
type LoggingConfig struct {
        Level  string      `yaml:"level" json:"level"`   // "debug", "info", "warn", "error"
        Format string      `yaml:"format" json:"format"` // "json" or "text"
        Output string      `yaml:"output" json:"output"` // "stderr", "stdout", or file path
        Loki   *LokiConfig `yaml:"loki,omitempty" json:"loki,omitempty"`
}

// LokiConfig configures Loki log shipping.
type LokiConfig struct {
        Enabled   bool              `yaml:"enabled" json:"enabled"`
        URL       string            `yaml:"url" json:"url"`               // e.g., http://localhost:3100
        BatchSize int               `yaml:"batch_size" json:"batch_size"` // Number of log entries before flush
        BatchWait time.Duration     `yaml:"batch_wait" json:"batch_wait"` // Max time before flush
        Labels    map[string]string `yaml:"labels" json:"labels"`         // Static labels for all log streams
        TenantID  string            `yaml:"tenant_id" json:"tenant_id"`   // X-Scope-OrgID header for multi-tenancy
}

// DaemonConfig configures daemon mode.
type DaemonConfig struct {
        Enabled        bool          `yaml:"enabled" json:"enabled"`
        HTTPAddr       string        `yaml:"http_addr" json:"http_addr"`
        MetricsAddr    string        `yaml:"metrics_addr" json:"metrics_addr"`
        Schedule       string        `yaml:"schedule" json:"schedule"`               // cron expression
        TriggerTimeout time.Duration `yaml:"trigger_timeout" json:"trigger_timeout"` // timeout for manual /trigger requests
        PIDFile        string        `yaml:"pid_file" json:"pid_file"`               // PID file path for single-instance enforcement
}

// MetricsConfig configures Prometheus metrics.
type MetricsConfig struct {
        Enabled   bool   `yaml:"enabled" json:"enabled"`
        Namespace string `yaml:"namespace" json:"namespace"`
}

// NotificationsConfig configures notification webhooks.
type NotificationsConfig struct {
        Webhooks []WebhookConfig `yaml:"webhooks,omitempty" json:"webhooks,omitempty"`
}

// WebhookConfig configures a single webhook endpoint.
type WebhookConfig struct {
        URL     string            `yaml:"url" json:"url"`
        Headers map[string]string `yaml:"headers,omitempty" json:"headers,omitempty"`
        Events  []string          `yaml:"events,omitempty" json:"events,omitempty"` // cleanup_started, cleanup_completed, cleanup_failed
        Timeout time.Duration     `yaml:"timeout,omitempty" json:"timeout,omitempty"`
}

// AuthConfig configures authentication for the HTTP API.
type AuthConfig struct {
        // Enabled enables authentication. When false, all endpoints are accessible without authentication.
        Enabled bool `yaml:"enabled" json:"enabled"`
        // APIKeys configures API key authentication.
        APIKeys *APIKeyConfig `yaml:"api_keys,omitempty" json:"api_keys,omitempty"`
        // PublicPaths are paths that don't require authentication (e.g., /health).
        PublicPaths []string `yaml:"public_paths,omitempty" json:"public_paths,omitempty"`
}

// APIKeyConfig configures API key authentication.
type APIKeyConfig struct {
        // Enabled enables API key authentication.
        Enabled bool `yaml:"enabled" json:"enabled"`
        // Key is a single API key for simple setups. Hidden from /api/config endpoint.
        Key string `yaml:"key,omitempty" json:"-"`
        // KeyEnv is the name of an environment variable containing the API key.
        KeyEnv string `yaml:"key_env,omitempty" json:"key_env,omitempty"`
        // KeysFile is the path to a file containing multiple keys.
        KeysFile string `yaml:"keys_file,omitempty" json:"keys_file,omitempty"`
        // HeaderName is the header name for API key authentication (default: X-API-Key).
        HeaderName string `yaml:"header_name,omitempty" json:"header_name,omitempty"`
}

// Default returns a Config with sensible defaults.
func Default() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Version: 1,
                Scan: ScanConfig{
                        Roots:          []string{},
                        Recursive:      true,
                        MaxDepth:       0,
                        FollowSymlinks: false,
                        IncludeDirs:    false,
                        IncludeFiles:   true,
                },
                Policy: PolicyConfig{
                        MinAgeDays:    30,
                        MinSizeMB:     0,
                        Extensions:    []string{},
                        Exclusions:    []string{},
                        CompositeMode: "and",
                },
                Safety: SafetyConfig{
                        ProtectedPaths: []string{
                                "/boot", "/etc", "/usr", "/var",
                                "/sys", "/proc", "/dev",
                        },
                        AllowDirDelete:       false,
                        EnforceMountBoundary: false,
                },
                Execution: ExecutionConfig{
                        Mode:        "dry-run",
                        Timeout:     30 * time.Second,
                        AuditPath:   "",
                        MaxItems:    25,
                        TrashPath:   "",                 // Empty = permanent delete (no soft-delete)
                        TrashMaxAge: 7 * 24 * time.Hour, // 7 days default if trash is enabled
                },
                Logging: LoggingConfig{
                        Level:  "info",
                        Format: "json",
                        Output: "stderr",
                        Loki: &amp;LokiConfig{
                                Enabled:   false,
                                URL:       "http://localhost:3100",
                                BatchSize: 100,
                                BatchWait: 5 * time.Second,
                                Labels: map[string]string{
                                        "service": "storage-sage",
                                },
                                TenantID: "",
                        },
                },
                Daemon: DaemonConfig{
                        Enabled:        false,
                        HTTPAddr:       ":8080",
                        MetricsAddr:    ":9090",
                        Schedule:       "",
                        TriggerTimeout: 30 * time.Minute,
                        PIDFile:        "", // Empty = no PID file
                },
                Metrics: MetricsConfig{
                        Enabled:   false,
                        Namespace: "storage_sage",
                },
                Notifications: NotificationsConfig{
                        Webhooks: []WebhookConfig{},
                },
                Auth: &amp;AuthConfig{
                        Enabled:     false, // Backwards compatible - disabled by default
                        PublicPaths: []string{"/health"},
                },
        }
}</span>

// Load reads a config file from the given path.
func Load(path string) (*Config, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading config file: %w", err)
        }</span>

        <span class="cov0" title="0">cfg := Default()
        if err := yaml.Unmarshal(data, cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parsing config file: %w", err)
        }</span>

        <span class="cov0" title="0">return cfg, nil</span>
}

// LoadOrDefault loads config from path if it exists, otherwise returns defaults.
func LoadOrDefault(path string) (*Config, error) <span class="cov0" title="0">{
        if path == "" </span><span class="cov0" title="0">{
                return Default(), nil
        }</span>

        // Check if file exists
        <span class="cov0" title="0">if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return Default(), nil
        }</span>

        <span class="cov0" title="0">return Load(path)</span>
}

// FindConfigFile searches for a config file in standard locations.
func FindConfigFile() string <span class="cov0" title="0">{
        candidates := []string{
                "storage-sage.yaml",
                "storage-sage.yml",
                filepath.Join(os.Getenv("HOME"), ".config", "storage-sage", "config.yaml"),
                "/etc/storage-sage/config.yaml",
        }

        for _, path := range candidates </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

// Save writes the config to the given path.
func (c *Config) Save(path string) error <span class="cov0" title="0">{
        data, err := yaml.Marshal(c)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshaling config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(path, data, 0600); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("writing config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package config

import (
        "fmt"
        "net"
        "net/url"
        "path/filepath"
        "strings"
        "time"
)

// ValidationError contains details about a single validation failure.
type ValidationError struct {
        Field   string
        Message string
}

func (e ValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("config validation failed: %s: %s", e.Field, e.Message)
}</span>

// ValidationErrors is a collection of validation errors.
type ValidationErrors []ValidationError

func (e ValidationErrors) Error() string <span class="cov8" title="1">{
        if len(e) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">var sb strings.Builder
        sb.WriteString("config validation failed:\n")
        for _, err := range e </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("  - %s: %s\n", err.Field, err.Message))
        }</span>
        <span class="cov8" title="1">return sb.String()</span>
}

// RequiredProtectedPaths are the minimum paths that MUST be protected.
var RequiredProtectedPaths = []string{
        "/boot", "/etc", "/usr", "/var", "/sys", "/proc", "/dev",
}

// ValidModes are the allowed execution modes.
var ValidModes = []string{"dry-run", "execute"}

// ValidLogLevels are the allowed log levels.
var ValidLogLevels = []string{"debug", "info", "warn", "error"}

// ValidLogFormats are the allowed log formats.
var ValidLogFormats = []string{"json", "text"}

// ValidCompositeModes are the allowed composite policy modes.
var ValidCompositeModes = []string{"and", "or"}

// Validate performs comprehensive validation of the configuration.
// It returns all validation errors found (not just the first).
// Returns nil if the configuration is valid.
func Validate(cfg *Config) error <span class="cov8" title="1">{
        var errs ValidationErrors

        errs = append(errs, ValidateRoots(cfg.Scan.Roots)...)
        errs = append(errs, ValidatePolicy(cfg.Policy)...)
        errs = append(errs, ValidateSafety(cfg.Safety)...)
        errs = append(errs, ValidateExecution(cfg.Execution)...)
        errs = append(errs, ValidateLogging(cfg.Logging)...)
        errs = append(errs, ValidateDaemon(cfg.Daemon)...)
        if cfg.Auth != nil </span><span class="cov8" title="1">{
                errs = append(errs, ValidateAuth(*cfg.Auth)...)
        }</span>

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateFinal performs validation after CLI flags have been merged.
// This catches errors that depend on the final merged state.
func ValidateFinal(cfg *Config) error <span class="cov8" title="1">{
        var errs ValidationErrors

        // After merge, at least one root MUST be provided
        if len(cfg.Scan.Roots) == 0 </span><span class="cov8" title="1">{
                errs = append(errs, ValidationError{
                        Field:   "scan.roots",
                        Message: "at least one root directory is required (via config or -root flag)",
                })
        }</span>

        // Re-validate roots in final state
        <span class="cov8" title="1">errs = append(errs, ValidateRoots(cfg.Scan.Roots)...)

        if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return errs
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateRoots checks that scan.roots are valid (absolute, clean paths).
func ValidateRoots(roots []string) []ValidationError <span class="cov8" title="1">{
        var errs []ValidationError

        for i, root := range roots </span><span class="cov8" title="1">{
                if root == "" </span><span class="cov8" title="1">{
                        errs = append(errs, ValidationError{
                                Field:   fmt.Sprintf("scan.roots[%d]", i),
                                Message: "path must not be empty",
                        })
                        continue</span>
                }

                // Must be absolute
                <span class="cov8" title="1">if !filepath.IsAbs(root) </span><span class="cov8" title="1">{
                        errs = append(errs, ValidationError{
                                Field:   fmt.Sprintf("scan.roots[%d]", i),
                                Message: fmt.Sprintf("path must be absolute: %q", root),
                        })
                        continue</span>
                }

                // Must be cleaned (no . or ..)
                <span class="cov8" title="1">cleaned := filepath.Clean(root)
                if root != cleaned </span><span class="cov8" title="1">{
                        errs = append(errs, ValidationError{
                                Field:   fmt.Sprintf("scan.roots[%d]", i),
                                Message: fmt.Sprintf("path must be clean (use %q not %q)", cleaned, root),
                        })
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

// ValidatePolicy checks policy constraints.
func ValidatePolicy(pol PolicyConfig) []ValidationError <span class="cov8" title="1">{
        var errs []ValidationError

        // min_age_days &gt;= 0
        if pol.MinAgeDays &lt; 0 </span><span class="cov8" title="1">{
                errs = append(errs, ValidationError{
                        Field:   "policy.min_age_days",
                        Message: "must be &gt;= 0",
                })
        }</span>

        // min_size_mb &gt;= 0
        <span class="cov8" title="1">if pol.MinSizeMB &lt; 0 </span><span class="cov8" title="1">{
                errs = append(errs, ValidationError{
                        Field:   "policy.min_size_mb",
                        Message: "must be &gt;= 0",
                })
        }</span>

        // composite_mode must be "and" or "or" (or empty for default)
        <span class="cov8" title="1">if pol.CompositeMode != "" &amp;&amp; !contains(ValidCompositeModes, pol.CompositeMode) </span><span class="cov8" title="1">{
                errs = append(errs, ValidationError{
                        Field:   "policy.composite_mode",
                        Message: fmt.Sprintf("must be one of %v, got %q", ValidCompositeModes, pol.CompositeMode),
                })
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// ValidateSafety checks safety configuration for required protected paths.
func ValidateSafety(safe SafetyConfig) []ValidationError <span class="cov8" title="1">{
        var errs []ValidationError

        // Build set of configured protected paths (normalized)
        protectedSet := make(map[string]bool)
        for _, p := range safe.ProtectedPaths </span><span class="cov8" title="1">{
                protectedSet[filepath.Clean(p)] = true
        }</span>

        // Check that all required protected paths are present
        <span class="cov8" title="1">for _, required := range RequiredProtectedPaths </span><span class="cov8" title="1">{
                if !protectedSet[required] </span><span class="cov8" title="1">{
                        errs = append(errs, ValidationError{
                                Field:   "safety.protected_paths",
                                Message: fmt.Sprintf("must include required path: %s", required),
                        })
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

// ValidateExecution checks execution mode and audit path.
func ValidateExecution(exec ExecutionConfig) []ValidationError <span class="cov8" title="1">{
        var errs []ValidationError

        // mode must be "dry-run" or "execute"
        if !contains(ValidModes, exec.Mode) </span><span class="cov8" title="1">{
                errs = append(errs, ValidationError{
                        Field:   "execution.mode",
                        Message: fmt.Sprintf("must be one of %v, got %q", ValidModes, exec.Mode),
                })
        }</span>

        // max_items must be &gt; 0
        <span class="cov8" title="1">if exec.MaxItems &lt;= 0 </span><span class="cov8" title="1">{
                errs = append(errs, ValidationError{
                        Field:   "execution.max_items",
                        Message: "must be &gt; 0",
                })
        }</span>

        // Note: audit_path validation is intentionally relaxed for CLI-only mode
        // It will be empty by default and that's acceptable

        <span class="cov8" title="1">return errs</span>
}

// ValidateLogging checks logging configuration.
func ValidateLogging(log LoggingConfig) []ValidationError <span class="cov8" title="1">{
        var errs []ValidationError

        // level must be valid (or empty for default)
        if log.Level != "" &amp;&amp; !contains(ValidLogLevels, log.Level) </span><span class="cov8" title="1">{
                errs = append(errs, ValidationError{
                        Field:   "logging.level",
                        Message: fmt.Sprintf("must be one of %v, got %q", ValidLogLevels, log.Level),
                })
        }</span>

        // format must be "json" or "text" (or empty for default)
        <span class="cov8" title="1">if log.Format != "" &amp;&amp; !contains(ValidLogFormats, log.Format) </span><span class="cov8" title="1">{
                errs = append(errs, ValidationError{
                        Field:   "logging.format",
                        Message: fmt.Sprintf("must be one of %v, got %q", ValidLogFormats, log.Format),
                })
        }</span>

        // Validate Loki config if present
        <span class="cov8" title="1">if log.Loki != nil </span><span class="cov8" title="1">{
                errs = append(errs, ValidateLoki(*log.Loki)...)
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// ValidateLoki checks Loki configuration.
func ValidateLoki(loki LokiConfig) []ValidationError <span class="cov8" title="1">{
        var errs []ValidationError

        // If Loki is enabled, URL must be provided and valid
        if loki.Enabled </span><span class="cov0" title="0">{
                if loki.URL == "" </span><span class="cov0" title="0">{
                        errs = append(errs, ValidationError{
                                Field:   "logging.loki.url",
                                Message: "URL is required when Loki is enabled",
                        })
                }</span> else<span class="cov0" title="0"> {
                        // Validate URL format
                        u, err := url.Parse(loki.URL)
                        if err != nil </span><span class="cov0" title="0">{
                                errs = append(errs, ValidationError{
                                        Field:   "logging.loki.url",
                                        Message: fmt.Sprintf("invalid URL: %v", err),
                                })
                        }</span> else<span class="cov0" title="0"> if u.Scheme != "http" &amp;&amp; u.Scheme != "https" </span><span class="cov0" title="0">{
                                errs = append(errs, ValidationError{
                                        Field:   "logging.loki.url",
                                        Message: fmt.Sprintf("URL scheme must be http or https, got %q", u.Scheme),
                                })
                        }</span>
                }
        }

        // BatchSize must be positive if set
        <span class="cov8" title="1">if loki.BatchSize &lt; 0 </span><span class="cov0" title="0">{
                errs = append(errs, ValidationError{
                        Field:   "logging.loki.batch_size",
                        Message: "must be &gt;= 0",
                })
        }</span>

        // BatchWait must be positive if set
        <span class="cov8" title="1">if loki.BatchWait &lt; 0 </span><span class="cov0" title="0">{
                errs = append(errs, ValidationError{
                        Field:   "logging.loki.batch_wait",
                        Message: "must be &gt;= 0",
                })
        }</span>

        <span class="cov8" title="1">return errs</span>
}

// ValidateDaemon checks daemon configuration.
func ValidateDaemon(d DaemonConfig) []ValidationError <span class="cov8" title="1">{
        var errs []ValidationError

        // If daemon is enabled, validate its settings
        if d.Enabled </span><span class="cov8" title="1">{
                // Schedule must be provided when daemon is enabled
                if d.Schedule == "" </span><span class="cov8" title="1">{
                        errs = append(errs, ValidationError{
                                Field:   "daemon.schedule",
                                Message: "schedule is required when daemon mode is enabled",
                        })
                }</span> else<span class="cov8" title="1"> {
                        // Validate schedule is parseable
                        if _, err := parseSchedule(d.Schedule); err != nil </span><span class="cov8" title="1">{
                                errs = append(errs, ValidationError{
                                        Field:   "daemon.schedule",
                                        Message: fmt.Sprintf("invalid schedule %q: %v", d.Schedule, err),
                                })
                        }</span>
                }
        }

        // Validate HTTP address format if provided
        <span class="cov8" title="1">if d.HTTPAddr != "" </span><span class="cov8" title="1">{
                if _, _, err := net.SplitHostPort(d.HTTPAddr); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, ValidationError{
                                Field:   "daemon.http_addr",
                                Message: fmt.Sprintf("invalid address %q: %v", d.HTTPAddr, err),
                        })
                }</span>
        }

        // Validate metrics address format if provided
        <span class="cov8" title="1">if d.MetricsAddr != "" </span><span class="cov8" title="1">{
                if _, _, err := net.SplitHostPort(d.MetricsAddr); err != nil </span><span class="cov8" title="1">{
                        errs = append(errs, ValidationError{
                                Field:   "daemon.metrics_addr",
                                Message: fmt.Sprintf("invalid address %q: %v", d.MetricsAddr, err),
                        })
                }</span>
        }

        <span class="cov8" title="1">return errs</span>
}

// parseSchedule parses a simple schedule string into a duration.
// Supports: "1h", "30m", "6h", etc. or cron-like "@every 1h".
func parseSchedule(s string) (time.Duration, error) <span class="cov8" title="1">{
        // Handle @every syntax
        if len(s) &gt; 7 &amp;&amp; s[:7] == "@every " </span><span class="cov8" title="1">{
                s = s[7:]
        }</span>
        <span class="cov8" title="1">return time.ParseDuration(s)</span>
}

// contains checks if a string slice contains a value.
func contains(slice []string, val string) bool <span class="cov8" title="1">{
        for _, s := range slice </span><span class="cov8" title="1">{
                if s == val </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ValidateAuth checks authentication configuration.
func ValidateAuth(auth AuthConfig) []ValidationError <span class="cov8" title="1">{
        var errs []ValidationError

        // If auth is not enabled, no further validation needed
        if !auth.Enabled </span><span class="cov8" title="1">{
                return errs
        }</span>

        // If auth is enabled, at least one authentication method must be configured
        <span class="cov0" title="0">hasAuthMethod := false

        if auth.APIKeys != nil &amp;&amp; auth.APIKeys.Enabled </span><span class="cov0" title="0">{
                hasAuthMethod = true

                // Validate API key configuration
                errs = append(errs, ValidateAPIKeys(*auth.APIKeys)...)
        }</span>

        <span class="cov0" title="0">if !hasAuthMethod </span><span class="cov0" title="0">{
                errs = append(errs, ValidationError{
                        Field:   "auth",
                        Message: "at least one authentication method must be enabled when auth is enabled",
                })
        }</span>

        <span class="cov0" title="0">return errs</span>
}

// ValidateAPIKeys checks API key authentication configuration.
func ValidateAPIKeys(apiKeys APIKeyConfig) []ValidationError <span class="cov0" title="0">{
        var errs []ValidationError

        // At least one key source must be provided
        hasKeySource := apiKeys.Key != "" || apiKeys.KeyEnv != "" || apiKeys.KeysFile != ""
        if !hasKeySource </span><span class="cov0" title="0">{
                errs = append(errs, ValidationError{
                        Field:   "auth.api_keys",
                        Message: "at least one key source must be provided (key, key_env, or keys_file)",
                })
        }</span>

        // Validate key format if provided directly
        <span class="cov0" title="0">if apiKeys.Key != "" </span><span class="cov0" title="0">{
                if !validateAPIKeyFormat(apiKeys.Key) </span><span class="cov0" title="0">{
                        errs = append(errs, ValidationError{
                                Field:   "auth.api_keys.key",
                                Message: "invalid API key format: must be 'ss_' followed by 32 hex characters",
                        })
                }</span>
        }

        <span class="cov0" title="0">return errs</span>
}

// validateAPIKeyFormat checks if a key has the correct format.
// Valid format: "ss_" prefix followed by exactly 32 hex characters.
func validateAPIKeyFormat(key string) bool <span class="cov0" title="0">{
        const apiKeyPrefix = "ss_"
        const apiKeyLength = 3 + 32 // "ss_" + 32 hex chars

        if len(key) != apiKeyLength </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">if len(key) &lt; 3 || key[:3] != apiKeyPrefix </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check that the rest is valid hex
        <span class="cov0" title="0">for _, c := range key[3:] </span><span class="cov0" title="0">{
                if !((c &gt;= '0' &amp;&amp; c &lt;= '9') || (c &gt;= 'a' &amp;&amp; c &lt;= 'f') || (c &gt;= 'A' &amp;&amp; c &lt;= 'F')) </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package core

import "time"

// Canonical audit actions
const (
        AuditActionPlan    = "plan"
        AuditActionExecute = "execute"
)

// NewPlanAuditEvent standardizes plan-time audit shape.
func NewPlanAuditEvent(root string, mode Mode, it PlanItem) AuditEvent <span class="cov8" title="1">{
        return AuditEvent{
                Time:   time.Now(),
                Level:  "info",
                Action: AuditActionPlan,
                Path:   it.Candidate.Path,
                Fields: map[string]any{
                        "root":          root,
                        "mode":          string(mode),
                        "type":          string(it.Candidate.Type),
                        "size_bytes":    it.Candidate.SizeBytes,
                        "mod_time":      it.Candidate.ModTime,
                        "score":         it.Decision.Score,
                        "policy_allow":  it.Decision.Allow,
                        "policy_reason": it.Decision.Reason,
                        "safety_allow":  it.Safety.Allowed,
                        "safety_reason": reasonKey(it.Safety.Reason),
                },
        }
}</span>

// NewExecuteAuditEvent standardizes execute-time audit shape.
func NewExecuteAuditEvent(root string, mode Mode, it PlanItem, ar ActionResult) AuditEvent <span class="cov8" title="1">{
        resultAllow := ar.Reason == "would_delete" || ar.Reason == "deleted"

        return AuditEvent{
                Time:   time.Now(),
                Level:  "info",
                Action: AuditActionExecute,
                Path:   it.Candidate.Path,
                Fields: map[string]any{
                        "root":          root,
                        "mode":          string(mode),
                        "type":          string(it.Candidate.Type),
                        "size_bytes":    it.Candidate.SizeBytes,
                        "mod_time":      it.Candidate.ModTime,
                        "score":         it.Decision.Score,
                        "policy_allow":  it.Decision.Allow,
                        "policy_reason": it.Decision.Reason,
                        "safety_allow":  it.Safety.Allowed,
                        "safety_reason": reasonKey(executeSafetyReason(it, ar)),

                        // Execute-only fields
                        "result_allow":  resultAllow,
                        "result_reason": ar.Reason,
                        "deleted":       ar.Deleted,
                        "bytes_freed":   ar.BytesFreed,
                },
        }
}</span>

// reasonKey collapses reasons like "symlink_self:/path/to/file" -&gt; "symlink_self"
func reasonKey(s string) string <span class="cov8" title="1">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                if s[i] == ':' </span><span class="cov8" title="1">{
                        return s[:i]
                }</span>
        }
        <span class="cov0" title="0">return s</span>
}

// executeSafetyReason returns the best safety reason for execute-time audit.
// If execution was denied due to execute-time safety, prefer the reason carried in ar.Reason
// (e.g. "safety_deny_execute:symlink_self:/x"). Otherwise fall back to plan-time safety.
func executeSafetyReason(it PlanItem, ar ActionResult) string <span class="cov8" title="1">{
        const pfx = "safety_deny_execute:"
        if len(ar.Reason) &gt;= len(pfx) &amp;&amp; ar.Reason[:len(pfx)] == pfx </span><span class="cov8" title="1">{
                // everything after the prefix is the safety reason (may include ":/path" detail)
                return ar.Reason[len(pfx):]
        }</span>
        <span class="cov0" title="0">return it.Safety.Reason</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package core

import (
        "context"
        "errors"
        "path/filepath"
        "time"
)

type Mode string

const (
        ModeDryRun  Mode = "dry-run"
        ModeExecute Mode = "execute"
)

type TargetType string

const (
        TargetFile TargetType = "file"
        TargetDir  TargetType = "dir"
)

type Candidate struct {
        Root         string // absolute root that discovered this candidate
        Path         string
        Type         TargetType
        Score        int // policy priority at time of action
        SizeBytes    int64
        ModTime      time.Time
        IsSymlink    bool
        LinkTarget   string
        DeviceID     uint64
        RootDeviceID uint64 // Device ID of the scan root
        FoundAt      time.Time
}

type Decision struct {
        Allow  bool
        Reason string
        Score  int
        TTL    time.Duration
}

type SafetyVerdict struct {
        Allowed bool
        Reason  string
}

type PlanItem struct {
        Candidate Candidate
        Decision  Decision
        Safety    SafetyVerdict
}

type ActionResult struct {
        Path       string
        Type       TargetType
        Score      int // policy priority at time of action
        Mode       Mode
        Deleted    bool
        BytesFreed int64
        Reason     string
        StartedAt  time.Time
        FinishedAt time.Time
        Err        error
}

var (
        ErrNotAllowed          = errors.New("not allowed")
        ErrProtectedPath       = errors.New("protected path")
        ErrOutsideAllowedRoots = errors.New("outside allowed roots")
        ErrSymlinkEscape       = errors.New("symlink escape")
        ErrUnsafeConfig        = errors.New("unsafe config")
)

type Scanner interface {
        Scan(ctx context.Context, req ScanRequest) (&lt;-chan Candidate, &lt;-chan error)
}

type ScanRequest struct {
        Roots          []string
        Recursive      bool
        FollowSymlinks bool
        MaxDepth       int
        IncludeDirs    bool
        IncludeFiles   bool
}

type Policy interface {
        Evaluate(ctx context.Context, cand Candidate, env EnvSnapshot) Decision
}

type Safety interface {
        Validate(ctx context.Context, cand Candidate, cfg SafetyConfig) SafetyVerdict
}

type Planner interface {
        BuildPlan(
                ctx context.Context,
                in &lt;-chan Candidate,
                pol Policy,
                safe Safety,
                env EnvSnapshot,
                cfg SafetyConfig,
        ) ([]PlanItem, error)
}

type Deleter interface {
        Execute(ctx context.Context, item PlanItem, mode Mode) ActionResult
}

type Auditor interface {
        Record(ctx context.Context, evt AuditEvent)
}

type AuditEvent struct {
        Time   time.Time
        Level  string
        Action string
        Path   string
        Fields map[string]any
        Err    error
}

// Metrics defines the interface for collecting operational metrics.
type Metrics interface {
        // Scanning metrics
        IncFilesScanned(root string)
        IncDirsScanned(root string)
        ObserveScanDuration(root string, duration time.Duration)

        // Planning metrics
        IncPolicyDecision(reason string, allowed bool)
        IncSafetyVerdict(reason string, allowed bool)
        SetBytesEligible(bytes int64)
        SetFilesEligible(count int)

        // Execution metrics
        IncFilesDeleted(root string)
        IncDirsDeleted(root string)
        AddBytesFreed(bytes int64)
        IncDeleteErrors(reason string)

        // System metrics
        SetDiskUsage(percent float64)
        SetCPUUsage(percent float64)

        // Daemon metrics
        SetLastRunTimestamp(t time.Time)
}

type EnvProvider interface {
        Snapshot(ctx context.Context) (EnvSnapshot, error)
}

type EnvSnapshot struct {
        Now         time.Time
        DiskUsedPct float64
        CPUUsedPct  float64
}

type SafetyConfig struct {
        AllowedRoots         []string
        ProtectedPaths       []string
        AllowDirDelete       bool
        EnforceMountBoundary bool
}

func Normalize(p string) string <span class="cov0" title="0">{
        return filepath.Clean(p)
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package daemon

import (
        "context"
        "encoding/json"
        "fmt"
        "io/fs"
        "net"
        "net/http"
        "os"
        "os/signal"
        "runtime/debug"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "syscall"
        "time"

        "github.com/ChrisB0-2/storage-sage/internal/auditor"
        "github.com/ChrisB0-2/storage-sage/internal/auth"
        "github.com/ChrisB0-2/storage-sage/internal/config"
        "github.com/ChrisB0-2/storage-sage/internal/logger"
        "github.com/ChrisB0-2/storage-sage/internal/pidfile"
        "github.com/ChrisB0-2/storage-sage/internal/trash"
        "github.com/ChrisB0-2/storage-sage/internal/web"
)

// State represents the current daemon state.
type State int32

const (
        StateStarting State = iota
        StateReady
        StateRunning
        StateStopping
        StateStopped
)

// State string constants.
const (
        stateStrStarting = "starting"
        stateStrReady    = "ready"
        stateStrRunning  = "running"
        stateStrStopping = "stopping"
        stateStrStopped  = "stopped"
        stateStrUnknown  = "unknown"
)

func (s State) String() string <span class="cov8" title="1">{
        switch s </span>{
        case StateStarting:<span class="cov8" title="1">
                return stateStrStarting</span>
        case StateReady:<span class="cov8" title="1">
                return stateStrReady</span>
        case StateRunning:<span class="cov8" title="1">
                return stateStrRunning</span>
        case StateStopping:<span class="cov8" title="1">
                return stateStrStopping</span>
        case StateStopped:<span class="cov8" title="1">
                return stateStrStopped</span>
        default:<span class="cov8" title="1">
                return stateStrUnknown</span>
        }
}

// RunFunc is the function called on each scheduled run.
type RunFunc func(ctx context.Context) error

// Daemon manages the lifecycle of a long-running storage-sage process.
type Daemon struct {
        log            logger.Logger
        runFunc        RunFunc
        schedule       string
        httpAddr       string
        triggerTimeout time.Duration
        pidFilePath    string
        runWaitTimeout time.Duration // timeout for waiting on in-flight runs during shutdown

        // Optional references for API endpoints
        cfg     *config.Config
        auditor *auditor.SQLiteAuditor
        trash   *trash.Manager

        // Optional authentication middleware
        authMiddleware *auth.Middleware
        rbacMiddleware *auth.RBACMiddleware

        state       atomic.Int32
        running     atomic.Bool
        lastRun     time.Time
        lastErr     error
        runCount    int64
        mu          sync.RWMutex
        stopCh      chan struct{}
        stopOnce    sync.Once
        auditorOnce sync.Once      // ensures auditor Close() is called exactly once
        runsWG      sync.WaitGroup // tracks in-flight runs (scheduled + API-triggered)
        httpServer  *http.Server
        pidFile     *pidfile.PIDFile
}

// Config holds daemon configuration.
type Config struct {
        Schedule       string        // Cron expression (e.g., "0 */6 * * *" for every 6 hours)
        HTTPAddr       string        // Address for health/ready endpoints (e.g., ":8080")
        TriggerTimeout time.Duration // Timeout for manual trigger requests (default: 30m)
        PIDFile        string        // Path to PID file for single-instance enforcement
        RunWaitTimeout time.Duration // Timeout for waiting on in-flight runs during shutdown (default: 10s)

        // Optional: references for API endpoints
        AppConfig *config.Config         // Application config to expose via /api/config
        Auditor   *auditor.SQLiteAuditor // Auditor for /api/audit/* endpoints
        Trash     *trash.Manager         // Trash manager for /api/trash/* endpoints

        // Optional: authentication middleware
        AuthMiddleware *auth.Middleware     // Authentication middleware
        RBACMiddleware *auth.RBACMiddleware // Role-based access control middleware
}

// New creates a new daemon instance.
func New(log logger.Logger, runFunc RunFunc, cfg Config) *Daemon <span class="cov8" title="1">{
        if log == nil </span><span class="cov8" title="1">{
                log = logger.NewNop()
        }</span>
        <span class="cov8" title="1">if cfg.HTTPAddr == "" </span><span class="cov8" title="1">{
                cfg.HTTPAddr = ":8080"
        }</span>
        <span class="cov8" title="1">if cfg.TriggerTimeout &lt;= 0 </span><span class="cov8" title="1">{
                cfg.TriggerTimeout = 30 * time.Minute
        }</span>
        <span class="cov8" title="1">if cfg.RunWaitTimeout &lt;= 0 </span><span class="cov8" title="1">{
                cfg.RunWaitTimeout = 10 * time.Second
        }</span>

        <span class="cov8" title="1">d := &amp;Daemon{
                log:            log,
                runFunc:        runFunc,
                schedule:       cfg.Schedule,
                httpAddr:       cfg.HTTPAddr,
                triggerTimeout: cfg.TriggerTimeout,
                runWaitTimeout: cfg.RunWaitTimeout,
                pidFilePath:    cfg.PIDFile,
                cfg:            cfg.AppConfig,
                auditor:        cfg.Auditor,
                trash:          cfg.Trash,
                authMiddleware: cfg.AuthMiddleware,
                rbacMiddleware: cfg.RBACMiddleware,
                stopCh:         make(chan struct{}),
        }
        d.state.Store(int32(StateStarting))

        return d</span>
}

// Run starts the daemon and blocks until shutdown.
// It handles SIGINT and SIGTERM for graceful shutdown.
// The daemon takes ownership of the configured auditor and will close it on shutdown.
func (d *Daemon) Run(ctx context.Context) error <span class="cov8" title="1">{
        d.log.Info("daemon starting", logger.F("http_addr", d.httpAddr), logger.F("schedule", d.schedule))

        // Ensure auditor is closed on any exit path (normal, panic, early return)
        defer d.closeAuditor()

        // Acquire PID file lock (prevents multiple instances)
        if d.pidFilePath != "" </span><span class="cov8" title="1">{
                pf, err := pidfile.New(d.pidFilePath)
                if err != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("failed to acquire pid file lock: %w", err)
                }</span>
                <span class="cov8" title="1">d.pidFile = pf
                d.log.Info("pid file acquired", logger.F("path", d.pidFilePath))

                // Ensure PID file is released on exit
                defer func() </span><span class="cov8" title="1">{
                        if err := d.pidFile.Close(); err != nil </span><span class="cov0" title="0">{
                                d.log.Warn("failed to release pid file", logger.F("error", err.Error()))
                        }</span> else<span class="cov8" title="1"> {
                                d.log.Debug("pid file released")
                        }</span>
                }()
        }

        // Set up signal handling
        <span class="cov8" title="1">sigCh := make(chan os.Signal, 1)
        signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)

        // Start HTTP server for health endpoints
        if err := d.startHTTP(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start HTTP server: %w", err)
        }</span>

        // Mark as ready
        <span class="cov8" title="1">d.state.Store(int32(StateReady))
        d.log.Info("daemon ready")

        // Create cancellable context
        ctx, cancel := context.WithCancel(ctx)
        defer cancel()

        // Start scheduler if schedule is configured
        var schedulerDone chan struct{}
        if d.schedule != "" </span><span class="cov8" title="1">{
                schedulerDone = make(chan struct{})
                go d.runScheduler(ctx, schedulerDone)
        }</span>

        // Wait for shutdown signal
        <span class="cov8" title="1">select </span>{
        case sig := &lt;-sigCh:<span class="cov0" title="0">
                d.log.Info("received signal", logger.F("signal", sig.String()))</span>
        case &lt;-ctx.Done():<span class="cov8" title="1">
                d.log.Info("context canceled")</span>
        case &lt;-d.stopCh:<span class="cov8" title="1">
                d.log.Info("stop requested")</span>
        }

        // Begin shutdown
        <span class="cov8" title="1">d.state.Store(int32(StateStopping))
        d.log.Info("daemon stopping")

        // Cancel context to stop scheduler
        cancel()

        // Wait for scheduler to finish
        if schedulerDone != nil </span><span class="cov8" title="1">{
                &lt;-schedulerDone
        }</span>

        // Stop HTTP server
        <span class="cov8" title="1">shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer shutdownCancel()
        if err := d.httpServer.Shutdown(shutdownCtx); err != nil </span><span class="cov0" title="0">{
                d.log.Warn("HTTP server shutdown error", logger.F("error", err.Error()))
        }</span>

        // Wait for any in-flight runs to complete (or timeout)
        <span class="cov8" title="1">d.log.Debug("waiting for in-flight runs to complete")
        if !d.waitForRuns(d.runWaitTimeout) </span><span class="cov8" title="1">{
                d.log.Warn("timed out waiting for in-flight runs", logger.F("timeout", d.runWaitTimeout.String()))
        }</span>

        // Close auditor (also called via defer, but explicit call makes shutdown order clear)
        <span class="cov8" title="1">d.closeAuditor()

        d.state.Store(int32(StateStopped))
        d.log.Info("daemon stopped")

        return nil</span>
}

// Stop signals the daemon to shut down.
func (d *Daemon) Stop() <span class="cov8" title="1">{
        d.stopOnce.Do(func() </span><span class="cov8" title="1">{
                close(d.stopCh)
        }</span>)
}

// closeAuditor closes the auditor if configured, exactly once.
// Safe to call multiple times; subsequent calls are no-ops.
// Errors are logged but do not fail the shutdown.
func (d *Daemon) closeAuditor() <span class="cov8" title="1">{
        d.auditorOnce.Do(func() </span><span class="cov8" title="1">{
                if d.auditor == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">d.log.Debug("closing auditor")
                if err := d.auditor.Close(); err != nil </span><span class="cov0" title="0">{
                        d.log.Warn("failed to close auditor", logger.F("error", err.Error()))
                }</span> else<span class="cov8" title="1"> {
                        d.log.Debug("auditor closed")
                }</span>
        })
}

// waitForRuns waits for all in-flight runs to complete with a timeout.
// Returns true if all runs completed, false if timed out.
func (d *Daemon) waitForRuns(timeout time.Duration) bool <span class="cov8" title="1">{
        done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                d.runsWG.Wait()
                close(done)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1">
                return true</span>
        case &lt;-time.After(timeout):<span class="cov8" title="1">
                return false</span>
        }
}

// TriggerRun manually triggers a run (for API use).
// Returns error if a run is already in progress.
// Includes panic recovery to prevent API handler crashes.
func (d *Daemon) TriggerRun(ctx context.Context) (err error) <span class="cov8" title="1">{
        if !d.running.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                return fmt.Errorf("run already in progress")
        }</span>

        // Track this run for graceful shutdown (must defer Done before running.Store(false))
        <span class="cov8" title="1">d.runsWG.Add(1)
        defer d.runsWG.Done()
        defer d.running.Store(false)

        // Panic recovery for API-triggered runs
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        stack := debug.Stack()
                        d.log.Error("trigger run panic recovered",
                                logger.F("panic", fmt.Sprintf("%v", r)),
                                logger.F("stack", string(stack)))

                        // Record the panic as an error
                        d.mu.Lock()
                        d.lastErr = fmt.Errorf("trigger panic: %v", r)
                        d.runCount++
                        d.lastRun = time.Now()
                        d.mu.Unlock()

                        // Return error to caller instead of crashing
                        err = fmt.Errorf("run panicked: %v", r)
                }</span>
        }()

        <span class="cov8" title="1">return d.executeRun(ctx)</span>
}

// State returns the current daemon state.
func (d *Daemon) State() State <span class="cov8" title="1">{
        return State(d.state.Load())
}</span>

// IsRunning returns true if a cleanup run is currently in progress.
func (d *Daemon) IsRunning() bool <span class="cov8" title="1">{
        return d.running.Load()
}</span>

// LastRun returns info about the last run.
func (d *Daemon) LastRun() (time.Time, int64, error) <span class="cov8" title="1">{
        d.mu.RLock()
        defer d.mu.RUnlock()
        return d.lastRun, d.runCount, d.lastErr
}</span>

// runScheduler runs the cleanup on the configured schedule.
// It includes panic recovery to prevent the daemon from crashing on unhandled panics.
func (d *Daemon) runScheduler(ctx context.Context, done chan struct{}) <span class="cov8" title="1">{
        defer close(done)

        // Panic recovery: log stack trace and mark daemon as stopped.
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        stack := debug.Stack()
                        d.log.Error("scheduler panic recovered",
                                logger.F("panic", fmt.Sprintf("%v", r)),
                                logger.F("stack", string(stack)))

                        // Record the panic as an error in lastErr for visibility
                        d.mu.Lock()
                        d.lastErr = fmt.Errorf("scheduler panic: %v", r)
                        d.mu.Unlock()

                        // Transition to stopped state - the daemon is no longer functional
                        d.state.Store(int32(StateStopped))
                        d.running.Store(false)

                        // Signal stop to allow graceful cleanup
                        d.Stop()
                }</span>
        }()

        <span class="cov8" title="1">interval, err := parseSchedule(d.schedule)
        if err != nil </span><span class="cov8" title="1">{
                d.log.Error("invalid schedule", logger.F("schedule", d.schedule), logger.F("error", err.Error()))
                return
        }</span>

        <span class="cov8" title="1">d.log.Info("scheduler started", logger.F("interval", interval.String()))

        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        d.log.Debug("scheduler stopping")
                        return</span>
                case &lt;-ticker.C:<span class="cov8" title="1">
                        if d.running.CompareAndSwap(false, true) </span><span class="cov8" title="1">{
                                // Track this run for graceful shutdown
                                d.runsWG.Add(1)
                                func() </span><span class="cov8" title="1">{
                                        defer d.runsWG.Done()
                                        defer d.running.Store(false)
                                        d.state.Store(int32(StateRunning))
                                        d.safeExecuteRun(ctx)
                                        d.state.Store(int32(StateReady))
                                }</span>()
                        } else<span class="cov0" title="0"> {
                                d.log.Warn("skipping scheduled run - previous run still in progress")
                        }</span>
                }
        }
}

// safeExecuteRun wraps executeRun with panic recovery.
// This ensures a panic in the run function doesn't crash the scheduler goroutine.
func (d *Daemon) safeExecuteRun(ctx context.Context) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        stack := debug.Stack()
                        d.log.Error("run panic recovered",
                                logger.F("panic", fmt.Sprintf("%v", r)),
                                logger.F("stack", string(stack)))

                        // Record the panic as an error
                        d.mu.Lock()
                        d.lastErr = fmt.Errorf("run panic: %v", r)
                        d.runCount++
                        d.lastRun = time.Now()
                        d.mu.Unlock()
                }</span>
        }()

        <span class="cov8" title="1">err := d.executeRun(ctx)
        if err != nil &amp;&amp; ctx.Err() == nil </span><span class="cov8" title="1">{
                d.log.Error("scheduled run failed", logger.F("error", err.Error()))
        }</span>
}

// executeRun performs a single cleanup run.
func (d *Daemon) executeRun(ctx context.Context) error <span class="cov8" title="1">{
        d.log.Info("starting cleanup run")
        start := time.Now()

        err := d.runFunc(ctx)

        d.mu.Lock()
        d.lastRun = start
        d.lastErr = err
        d.runCount++
        d.mu.Unlock()

        duration := time.Since(start)
        if err != nil </span><span class="cov8" title="1">{
                d.log.Error("cleanup run failed",
                        logger.F("duration", duration.String()),
                        logger.F("error", err.Error()))
        }</span> else<span class="cov8" title="1"> {
                d.log.Info("cleanup run completed", logger.F("duration", duration.String()))
        }</span>

        <span class="cov8" title="1">return err</span>
}

// parseSchedule parses a simple schedule string into a duration.
// Supports: "1h", "30m", "6h", etc. or cron-like "@every 1h".
func parseSchedule(s string) (time.Duration, error) <span class="cov8" title="1">{
        // Handle @every syntax
        if len(s) &gt; 7 &amp;&amp; s[:7] == "@every " </span><span class="cov8" title="1">{
                s = s[7:]
        }</span>

        <span class="cov8" title="1">return time.ParseDuration(s)</span>
}

// startHTTP initializes and starts the HTTP server for health endpoints.
func (d *Daemon) startHTTP() error <span class="cov8" title="1">{
        mux := http.NewServeMux()

        // Health endpoint - basic liveness check
        mux.HandleFunc("/health", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov8" title="1">{
                w.Header().Set("Content-Type", "application/json")
                w.WriteHeader(http.StatusOK)
                _, _ = fmt.Fprintf(w, `{"status":"ok","state":"%s"}`, d.State().String())
        }</span>)

        // Ready endpoint - readiness check (not ready if stopping/stopped or disk critically full)
        <span class="cov8" title="1">mux.HandleFunc("/ready", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov8" title="1">{
                state := d.State()
                w.Header().Set("Content-Type", "application/json")

                // Check if daemon is in a ready state
                if state != StateReady &amp;&amp; state != StateRunning </span><span class="cov8" title="1">{
                        w.WriteHeader(http.StatusServiceUnavailable)
                        _, _ = fmt.Fprintf(w, `{"ready":false,"state":"%s","reason":"daemon not ready"}`, state.String())
                        return
                }</span>

                // Check disk space on scan roots if config is available
                <span class="cov8" title="1">if d.cfg != nil &amp;&amp; len(d.cfg.Scan.Roots) &gt; 0 </span><span class="cov8" title="1">{
                        for _, root := range d.cfg.Scan.Roots </span><span class="cov8" title="1">{
                                usedPct, err := getDiskUsagePercent(root)
                                if err != nil </span><span class="cov0" title="0">{
                                        // Log but don't fail readiness for inaccessible paths
                                        d.log.Warn("disk check failed", logger.F("path", root), logger.F("error", err.Error()))
                                        continue</span>
                                }
                                // Fail readiness if disk is critically full (&gt;95%)
                                <span class="cov8" title="1">if usedPct &gt; 95.0 </span><span class="cov0" title="0">{
                                        w.WriteHeader(http.StatusServiceUnavailable)
                                        _, _ = fmt.Fprintf(w, `{"ready":false,"state":"%s","reason":"disk critically full","path":"%s","disk_used_percent":%.1f}`,
                                                state.String(), root, usedPct)
                                        return
                                }</span>
                        }
                }

                <span class="cov8" title="1">w.WriteHeader(http.StatusOK)
                _, _ = fmt.Fprintf(w, `{"ready":true,"state":"%s"}`, state.String())</span>
        })

        // Status endpoint - detailed status information
        <span class="cov8" title="1">mux.HandleFunc("/status", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov8" title="1">{
                lastRun, runCount, lastErr := d.LastRun()
                w.Header().Set("Content-Type", "application/json")

                errStr := ""
                if lastErr != nil </span><span class="cov8" title="1">{
                        errStr = lastErr.Error()
                }</span>

                <span class="cov8" title="1">lastRunStr := ""
                if !lastRun.IsZero() </span><span class="cov8" title="1">{
                        lastRunStr = lastRun.Format(time.RFC3339)
                }</span>

                <span class="cov8" title="1">d.writeJSONResponse(w, http.StatusOK, map[string]any{
                        "state":      d.State().String(),
                        "running":    d.IsRunning(),
                        "last_run":   lastRunStr,
                        "last_error": errStr,
                        "run_count":  runCount,
                        "schedule":   d.schedule,
                })</span>
        })

        // Trigger endpoint - manually trigger a run (POST only)
        <span class="cov8" title="1">mux.HandleFunc("/trigger", func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                        w.Header().Set("Allow", "POST")
                        http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
                        return
                }</span>

                <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")

                // Use request context with configurable timeout
                ctx, cancel := context.WithTimeout(r.Context(), d.triggerTimeout)
                defer cancel()

                if err := d.TriggerRun(ctx); err != nil </span><span class="cov8" title="1">{
                        d.writeJSONResponse(w, http.StatusConflict, map[string]any{
                                "triggered": false,
                                "error":     err.Error(),
                        })
                        return
                }</span>

                <span class="cov8" title="1">d.writeJSONResponse(w, http.StatusOK, map[string]any{"triggered": true})</span>
        })

        // API endpoints for frontend
        <span class="cov8" title="1">mux.HandleFunc("/api/config", d.handleAPIConfig)
        mux.HandleFunc("/api/audit/query", d.handleAuditQuery)
        mux.HandleFunc("/api/audit/stats", d.handleAuditStats)
        mux.HandleFunc("/api/trash", d.handleTrash)
        mux.HandleFunc("/api/trash/restore", d.handleTrashRestore)

        // Serve embedded frontend (SPA with fallback to index.html)
        d.setupStaticFileServer(mux)

        // Wrap handler with middleware (order matters: auth runs first, then RBAC)
        var handler http.Handler = mux
        if d.rbacMiddleware != nil </span><span class="cov0" title="0">{
                handler = d.rbacMiddleware.Wrap(handler)
        }</span>
        <span class="cov8" title="1">if d.authMiddleware != nil </span><span class="cov0" title="0">{
                // Auth must wrap outermost so it runs first and sets Identity in context
                handler = d.authMiddleware.Wrap(handler)
        }</span>

        <span class="cov8" title="1">d.httpServer = &amp;http.Server{
                Handler:           handler,
                ReadHeaderTimeout: 10 * time.Second,
        }

        // Create listener first to ensure port is available before returning
        ln, err := net.Listen("tcp", d.httpAddr)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to listen on %s: %w", d.httpAddr, err)
        }</span>

        // Start server in goroutine with the already-bound listener
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                if err := d.httpServer.Serve(ln); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        d.log.Error("HTTP server error", logger.F("error", err.Error()))
                }</span>
        }()

        <span class="cov8" title="1">return nil</span>
}

// handleAPIConfig returns the current running configuration as JSON.
func (d *Daemon) handleAPIConfig(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                w.Header().Set("Allow", "GET")
                http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")

        if d.cfg == nil </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusNotFound, "config not available")
                return
        }</span>

        // Return config as JSON
        <span class="cov8" title="1">d.writeJSONResponse(w, http.StatusOK, d.cfg)</span>
}

// Valid values for audit query filters.
var (
        validActions = map[string]bool{"": true, "plan": true, "execute": true, "error": true}
        validLevels  = map[string]bool{"": true, "info": true, "warn": true, "error": true, "debug": true}
)

const maxQueryLimit = 1000

// handleAuditQuery queries audit records with optional filters.
// Query params: since, until, action, level, path, limit
func (d *Daemon) handleAuditQuery(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                w.Header().Set("Allow", "GET")
                http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")

        if d.auditor == nil </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusNotFound, "auditor not available")
                return
        }</span>

        // Parse query parameters
        <span class="cov8" title="1">q := r.URL.Query()

        // Validate action parameter
        action := q.Get("action")
        if !validActions[action] </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusBadRequest, "invalid action: must be one of plan, execute, error")
                return
        }</span>

        // Validate level parameter
        <span class="cov8" title="1">level := q.Get("level")
        if !validLevels[level] </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusBadRequest, "invalid level: must be one of debug, info, warn, error")
                return
        }</span>

        <span class="cov8" title="1">filter := auditor.QueryFilter{
                Action: action,
                Level:  level,
                Path:   q.Get("path"),
        }

        // Parse time filters
        if since := q.Get("since"); since != "" </span><span class="cov8" title="1">{
                if t, err := parseTimeParam(since); err == nil </span><span class="cov8" title="1">{
                        filter.Since = t
                }</span>
        }
        <span class="cov8" title="1">if until := q.Get("until"); until != "" </span><span class="cov8" title="1">{
                if t, err := parseTimeParam(until); err == nil </span><span class="cov8" title="1">{
                        filter.Until = t
                }</span>
        }

        // Parse and validate limit (default 100, max 1000)
        <span class="cov8" title="1">filter.Limit = 100
        if limitStr := q.Get("limit"); limitStr != "" </span><span class="cov8" title="1">{
                limit, err := strconv.Atoi(limitStr)
                if err != nil || limit &lt; 1 </span><span class="cov8" title="1">{
                        d.writeJSONError(w, http.StatusBadRequest, "invalid limit: must be a positive integer")
                        return
                }</span>
                <span class="cov8" title="1">if limit &gt; maxQueryLimit </span><span class="cov8" title="1">{
                        limit = maxQueryLimit
                }</span>
                <span class="cov8" title="1">filter.Limit = limit</span>
        }

        // Query audit records
        <span class="cov8" title="1">records, err := d.auditor.Query(r.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                d.writeJSONError(w, http.StatusInternalServerError, "query failed: "+err.Error())
                return
        }</span>

        // Return records as JSON
        <span class="cov8" title="1">d.writeJSONResponse(w, http.StatusOK, records)</span>
}

// handleAuditStats returns audit statistics summary.
func (d *Daemon) handleAuditStats(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodGet </span><span class="cov8" title="1">{
                w.Header().Set("Allow", "GET")
                http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")

        if d.auditor == nil </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusNotFound, "auditor not available")
                return
        }</span>

        <span class="cov8" title="1">stats, err := d.auditor.Stats(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                d.writeJSONError(w, http.StatusInternalServerError, "stats failed: "+err.Error())
                return
        }</span>

        // Return stats as JSON
        <span class="cov8" title="1">d.writeJSONResponse(w, http.StatusOK, stats)</span>
}

// TrashItemResponse is the JSON representation of a trash item.
type TrashItemResponse struct {
        Name         string `json:"name"`
        OriginalPath string `json:"original_path"`
        Size         int64  `json:"size"`
        TrashedAt    string `json:"trashed_at"`
        IsDir        bool   `json:"is_dir"`
}

// handleTrash handles GET (list) and DELETE (empty) for /api/trash.
func (d *Daemon) handleTrash(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json")

        if d.trash == nil </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusNotFound, "trash not configured")
                return
        }</span>

        <span class="cov8" title="1">switch r.Method </span>{
        case http.MethodGet:<span class="cov8" title="1">
                d.handleTrashList(w)</span>
        case http.MethodDelete:<span class="cov8" title="1">
                d.handleTrashEmpty(w, r)</span>
        default:<span class="cov8" title="1">
                w.Header().Set("Allow", "GET, DELETE")
                http.Error(w, "method not allowed", http.StatusMethodNotAllowed)</span>
        }
}

// handleTrashList returns all items in trash.
func (d *Daemon) handleTrashList(w http.ResponseWriter) <span class="cov8" title="1">{
        items, err := d.trash.List()
        if err != nil </span><span class="cov0" title="0">{
                d.writeJSONError(w, http.StatusInternalServerError, "failed to list trash: "+err.Error())
                return
        }</span>

        // Convert to JSON response format
        <span class="cov8" title="1">response := make([]TrashItemResponse, 0, len(items))
        for _, item := range items </span><span class="cov8" title="1">{
                response = append(response, TrashItemResponse{
                        Name:         item.Name,
                        OriginalPath: item.OriginalPath,
                        Size:         item.Size,
                        TrashedAt:    item.TrashedAt.Format(time.RFC3339),
                        IsDir:        item.IsDir,
                })
        }</span>

        <span class="cov8" title="1">d.writeJSONResponse(w, http.StatusOK, response)</span>
}

// handleTrashEmpty permanently deletes items from trash.
// Query params: older_than (duration string like "7d", "24h"), all (boolean)
func (d *Daemon) handleTrashEmpty(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        q := r.URL.Query()

        // Check for "all" parameter
        if q.Get("all") == "true" </span><span class="cov8" title="1">{
                items, err := d.trash.List()
                if err != nil </span><span class="cov0" title="0">{
                        d.writeJSONError(w, http.StatusInternalServerError, "failed to list trash: "+err.Error())
                        return
                }</span>

                <span class="cov8" title="1">var deleted int
                var bytesFreed int64
                for _, item := range items </span><span class="cov0" title="0">{
                        if err := os.RemoveAll(item.TrashPath); err != nil </span><span class="cov0" title="0">{
                                d.log.Warn("failed to delete trash item", logger.F("path", item.TrashPath), logger.F("error", err.Error()))
                                continue</span>
                        }
                        <span class="cov0" title="0">_ = os.Remove(item.TrashPath + ".meta")
                        deleted++
                        bytesFreed += item.Size</span>
                }

                <span class="cov8" title="1">d.writeJSONResponse(w, http.StatusOK, map[string]any{
                        "deleted":     deleted,
                        "bytes_freed": bytesFreed,
                })
                return</span>
        }

        // Check for "older_than" parameter
        <span class="cov8" title="1">olderThan := q.Get("older_than")
        if olderThan == "" </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusBadRequest, "must specify 'older_than' duration (e.g., '7d', '24h') or 'all=true'")
                return
        }</span>

        // Parse duration
        <span class="cov8" title="1">duration, err := parseDurationWithDays(olderThan)
        if err != nil </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusBadRequest, "invalid duration: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">items, err := d.trash.List()
        if err != nil </span><span class="cov0" title="0">{
                d.writeJSONError(w, http.StatusInternalServerError, "failed to list trash: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">cutoff := time.Now().Add(-duration)
        var deleted int
        var bytesFreed int64

        for _, item := range items </span><span class="cov8" title="1">{
                if item.TrashedAt.Before(cutoff) </span><span class="cov8" title="1">{
                        if err := os.RemoveAll(item.TrashPath); err != nil </span><span class="cov0" title="0">{
                                d.log.Warn("failed to delete trash item", logger.F("path", item.TrashPath), logger.F("error", err.Error()))
                                continue</span>
                        }
                        <span class="cov8" title="1">_ = os.Remove(item.TrashPath + ".meta")
                        deleted++
                        bytesFreed += item.Size</span>
                }
        }

        <span class="cov8" title="1">d.writeJSONResponse(w, http.StatusOK, map[string]any{
                "deleted":     deleted,
                "bytes_freed": bytesFreed,
        })</span>
}

// TrashRestoreRequest is the JSON request body for restore.
type TrashRestoreRequest struct {
        Name string `json:"name"`
}

// handleTrashRestore restores an item from trash.
func (d *Daemon) handleTrashRestore(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if r.Method != http.MethodPost </span><span class="cov8" title="1">{
                w.Header().Set("Allow", "POST")
                http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json")

        if d.trash == nil </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusNotFound, "trash not configured")
                return
        }</span>

        // Parse request body
        <span class="cov8" title="1">var req TrashRestoreRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusBadRequest, "invalid request body: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">if req.Name == "" </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusBadRequest, "name is required")
                return
        }</span>

        // Find the item in trash
        <span class="cov8" title="1">items, err := d.trash.List()
        if err != nil </span><span class="cov0" title="0">{
                d.writeJSONError(w, http.StatusInternalServerError, "failed to list trash: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">var targetItem *trash.TrashItem
        for i := range items </span><span class="cov8" title="1">{
                if items[i].Name == req.Name </span><span class="cov8" title="1">{
                        targetItem = &amp;items[i]
                        break</span>
                }
        }

        <span class="cov8" title="1">if targetItem == nil </span><span class="cov8" title="1">{
                d.writeJSONError(w, http.StatusNotFound, "item not found in trash: "+req.Name)
                return
        }</span>

        // Restore the item
        <span class="cov8" title="1">originalPath, err := d.trash.Restore(targetItem.TrashPath)
        if err != nil </span><span class="cov0" title="0">{
                d.writeJSONError(w, http.StatusInternalServerError, "failed to restore: "+err.Error())
                return
        }</span>

        <span class="cov8" title="1">d.writeJSONResponse(w, http.StatusOK, map[string]any{
                "restored":      true,
                "original_path": originalPath,
        })</span>
}

// parseDurationWithDays parses a duration string that may include days (e.g., "7d", "24h").
func parseDurationWithDays(s string) (time.Duration, error) <span class="cov8" title="1">{
        // Handle day suffix
        if len(s) &gt; 1 &amp;&amp; s[len(s)-1] == 'd' </span><span class="cov8" title="1">{
                numStr := s[:len(s)-1]
                var n int
                if _, err := fmt.Sscanf(numStr, "%d", &amp;n); err == nil &amp;&amp; n &gt; 0 </span><span class="cov8" title="1">{
                        return time.Duration(n) * 24 * time.Hour, nil
                }</span>
                <span class="cov8" title="1">return 0, fmt.Errorf("invalid day duration: %s", s)</span>
        }

        // Fall back to standard duration parsing
        <span class="cov8" title="1">return time.ParseDuration(s)</span>
}

// setupStaticFileServer configures the mux to serve embedded frontend files.
// Uses SPA-style routing: serves index.html for any path that doesn't match a static file.
func (d *Daemon) setupStaticFileServer(mux *http.ServeMux) <span class="cov8" title="1">{
        distFS, err := web.DistFS()
        if err != nil </span><span class="cov0" title="0">{
                d.log.Warn("frontend not available", logger.F("error", err.Error()))
                return
        }</span>

        // Check if frontend is built
        <span class="cov8" title="1">if !web.HasDist() </span><span class="cov0" title="0">{
                d.log.Info("frontend not built, UI disabled")
                return
        }</span>

        // Create file server for static assets
        <span class="cov8" title="1">fileServer := http.FileServer(http.FS(distFS))

        // Serve static files with SPA fallback
        mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Skip API and health endpoints
                path := r.URL.Path
                if strings.HasPrefix(path, "/api/") ||
                        path == "/health" ||
                        path == "/ready" ||
                        path == "/status" ||
                        path == "/trigger" </span><span class="cov0" title="0">{
                        http.NotFound(w, r)
                        return
                }</span>

                // Try to serve the actual file
                <span class="cov0" title="0">cleanPath := strings.TrimPrefix(path, "/")
                if cleanPath == "" </span><span class="cov0" title="0">{
                        cleanPath = "index.html"
                }</span>

                // Check if file exists in embedded FS
                <span class="cov0" title="0">if _, err := fs.Stat(distFS, cleanPath); err == nil </span><span class="cov0" title="0">{
                        fileServer.ServeHTTP(w, r)
                        return
                }</span>

                // SPA fallback: serve index.html for all other routes
                <span class="cov0" title="0">indexFile, err := fs.ReadFile(distFS, "index.html")
                if err != nil </span><span class="cov0" title="0">{
                        http.NotFound(w, r)
                        return
                }</span>

                <span class="cov0" title="0">w.Header().Set("Content-Type", "text/html; charset=utf-8")
                _, _ = w.Write(indexFile)</span>
        })

        <span class="cov8" title="1">d.log.Info("frontend UI enabled")</span>
}

// writeJSONError writes a JSON error response with properly escaped message.
func (d *Daemon) writeJSONError(w http.ResponseWriter, status int, message string) <span class="cov8" title="1">{
        w.WriteHeader(status)
        resp := map[string]string{"error": message}
        if err := json.NewEncoder(w).Encode(resp); err != nil </span><span class="cov0" title="0">{
                d.log.Error("failed to encode JSON error response", logger.F("error", err.Error()))
        }</span>
}

// writeJSONResponse writes a JSON response with the given data.
func (d *Daemon) writeJSONResponse(w http.ResponseWriter, status int, data any) <span class="cov8" title="1">{
        w.WriteHeader(status)
        if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                d.log.Error("failed to encode JSON response", logger.F("error", err.Error()))
        }</span>
}

// parseTimeParam parses a time parameter from various formats.
// Supports: RFC3339, date (2006-01-02), and duration strings (24h, 7d).
func parseTimeParam(s string) (time.Time, error) <span class="cov8" title="1">{
        // Try RFC3339 first
        if t, err := time.Parse(time.RFC3339, s); err == nil </span><span class="cov8" title="1">{
                return t, nil
        }</span>

        // Try date format
        <span class="cov8" title="1">if t, err := time.Parse("2006-01-02", s); err == nil </span><span class="cov8" title="1">{
                return t, nil
        }</span>

        // Try duration format (e.g., "24h", "7d")
        <span class="cov8" title="1">if len(s) &gt; 1 </span><span class="cov8" title="1">{
                unit := s[len(s)-1]
                numStr := s[:len(s)-1]
                var multiplier time.Duration
                switch unit </span>{
                case 'h':<span class="cov8" title="1">
                        multiplier = time.Hour</span>
                case 'd':<span class="cov8" title="1">
                        multiplier = 24 * time.Hour</span>
                case 'm':<span class="cov8" title="1">
                        multiplier = time.Minute</span>
                }
                <span class="cov8" title="1">if multiplier &gt; 0 </span><span class="cov8" title="1">{
                        var n int
                        if _, err := fmt.Sscanf(numStr, "%d", &amp;n); err == nil &amp;&amp; n &gt; 0 </span><span class="cov8" title="1">{
                                return time.Now().Add(-time.Duration(n) * multiplier), nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return time.Time{}, fmt.Errorf("invalid time format: %s", s)</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">//go:build unix

package daemon

import (
        "fmt"
        "syscall"
)

// getDiskUsagePercent returns the disk usage percentage for the given path.
func getDiskUsagePercent(path string) (float64, error) <span class="cov8" title="1">{
        var stat syscall.Statfs_t
        if err := syscall.Statfs(path, &amp;stat); err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        // Bsize is int64 on Linux; ensure it's positive before converting to uint64
        <span class="cov8" title="1">if stat.Bsize &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid block size: %d", stat.Bsize)
        }</span>
        <span class="cov8" title="1">bsize := uint64(stat.Bsize)

        // Total and available blocks
        total := stat.Blocks * bsize
        avail := stat.Bavail * bsize

        if total == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">used := total - avail
        usedPct := (float64(used) / float64(total)) * 100.0
        return usedPct, nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package executor

import (
        "context"
        "errors"
        "io/fs"
        "os"
        "path/filepath"
        "time"

        "github.com/ChrisB0-2/storage-sage/internal/core"
        "github.com/ChrisB0-2/storage-sage/internal/logger"
        "github.com/ChrisB0-2/storage-sage/internal/metrics"
        "github.com/ChrisB0-2/storage-sage/internal/trash"
)

// Action result reason constants.
const (
        reasonWouldDelete  = "would_delete"
        reasonAlreadyGone  = "already_gone"
        reasonDeleted      = "deleted"
        reasonTrashed      = "trashed"
        reasonDeleteFailed = "delete_failed"
        reasonCtxCanceled  = "ctx_canceled"
)

// Simple is a safe-by-default deleter.
// It enforces an execute-time safety re-check (TOCTOU hard gate) immediately before mutation.
// If an Auditor is provided, it records an AuditEvent for each executed item outcome.
type Simple struct {
        safe    core.Safety
        aud     core.Auditor
        cfg     core.SafetyConfig
        now     func() time.Time
        log     logger.Logger
        metrics core.Metrics
        trash   *trash.Manager
}

// NewSimple creates an executor with no-op logging and metrics.
func NewSimple(safe core.Safety, cfg core.SafetyConfig) *Simple <span class="cov8" title="1">{
        return &amp;Simple{
                safe:    safe,
                cfg:     cfg,
                now:     time.Now,
                log:     logger.NewNop(),
                metrics: metrics.NewNoop(),
        }
}</span>

// NewSimpleWithLogger creates an executor with the given logger.
func NewSimpleWithLogger(safe core.Safety, cfg core.SafetyConfig, log logger.Logger) *Simple <span class="cov8" title="1">{
        if log == nil </span><span class="cov8" title="1">{
                log = logger.NewNop()
        }</span>
        <span class="cov8" title="1">return &amp;Simple{
                safe:    safe,
                cfg:     cfg,
                now:     time.Now,
                log:     log,
                metrics: metrics.NewNoop(),
        }</span>
}

// NewSimpleWithMetrics creates an executor with logger and metrics.
func NewSimpleWithMetrics(safe core.Safety, cfg core.SafetyConfig, log logger.Logger, m core.Metrics) *Simple <span class="cov8" title="1">{
        if log == nil </span><span class="cov8" title="1">{
                log = logger.NewNop()
        }</span>
        <span class="cov8" title="1">if m == nil </span><span class="cov8" title="1">{
                m = metrics.NewNoop()
        }</span>
        <span class="cov8" title="1">return &amp;Simple{
                safe:    safe,
                cfg:     cfg,
                now:     time.Now,
                log:     log,
                metrics: m,
        }</span>
}

// WithAuditor attaches an auditor (optional). Safe to pass nil.
func (e *Simple) WithAuditor(aud core.Auditor) *Simple <span class="cov8" title="1">{
        e.aud = aud
        return e
}</span>

// WithTrash attaches a trash manager for soft-delete. Safe to pass nil.
func (e *Simple) WithTrash(t *trash.Manager) *Simple <span class="cov0" title="0">{
        e.trash = t
        return e
}</span>

// Execute performs the action for one PlanItem.
//
// Hard gates in order:
//  1. policy allow (item.Decision.Allow)
//  2. scan-time safety allow (item.Safety.Allowed)
//  3. execute-time safety re-check (safe.Validate) to prevent TOCTOU
//  4. dry-run: report would-delete
//  5. execute: delete (file/dir) or trash, fail-closed
//
//nolint:gocyclo // Sequential gate checks with trash support; complexity reflects safety requirements
func (e *Simple) Execute(ctx context.Context, item core.PlanItem, mode core.Mode) (res core.ActionResult) <span class="cov8" title="1">{
        start := e.now()

        e.log.Debug("executing action", logger.F("path", item.Candidate.Path), logger.F("mode", string(mode)))

        res = core.ActionResult{
                Path:      item.Candidate.Path,
                Type:      item.Candidate.Type,
                Mode:      mode,
                Score:     item.Decision.Score,
                StartedAt: start,
        }

        // Always finalize + audit on return.
        // Uses named return value so defer modifications are visible to caller.
        defer func() </span><span class="cov8" title="1">{
                if res.FinishedAt.IsZero() </span><span class="cov8" title="1">{
                        res.FinishedAt = e.now()
                }</span>
                <span class="cov8" title="1">e.record(ctx, item, res)</span>
        }()

        // Cancellation check early.
        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                res.Reason = reasonCtxCanceled
                res.Err = ctx.Err()
                return res</span>
        default:<span class="cov8" title="1"></span>
        }

        // Gate 1: Policy
        <span class="cov8" title="1">if !item.Decision.Allow </span><span class="cov8" title="1">{
                res.Reason = "policy_deny:" + item.Decision.Reason
                return res
        }</span>

        // Gate 2: Scan-time safety verdict
        <span class="cov8" title="1">if !item.Safety.Allowed </span><span class="cov8" title="1">{
                res.Reason = "safety_deny_scan:" + item.Safety.Reason
                return res
        }</span>

        // Gate 3: Execute-time safety re-check (TOCTOU hard gate)
        // MUST happen immediately before any mutation.
        <span class="cov8" title="1">v := e.safe.Validate(ctx, item.Candidate, e.cfg)
        if !v.Allowed </span><span class="cov8" title="1">{
                res.Reason = "safety_deny_execute:" + v.Reason
                return res
        }</span>

        // Gate 4: Dry run
        <span class="cov8" title="1">if mode == core.ModeDryRun </span><span class="cov8" title="1">{
                res.Reason = reasonWouldDelete
                if item.Candidate.Type == core.TargetFile </span><span class="cov8" title="1">{
                        res.BytesFreed = item.Candidate.SizeBytes
                }</span>
                <span class="cov8" title="1">return res</span>
        }

        // Execute mode required to mutate.
        <span class="cov8" title="1">if mode != core.ModeExecute </span><span class="cov8" title="1">{
                res.Reason = "invalid_mode"
                res.Err = errors.New("invalid mode")
                return res
        }</span>

        // Gate 5: Perform deletion (fail-closed)
        // If trash is enabled, move to trash instead of permanent delete
        <span class="cov8" title="1">switch item.Candidate.Type </span>{
        case core.TargetFile:<span class="cov8" title="1">
                // Try soft-delete first if trash is configured
                if e.trash != nil </span><span class="cov0" title="0">{
                        trashPath, err := e.trash.MoveToTrash(item.Candidate.Path)
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                                        res.Reason = reasonAlreadyGone
                                        return res
                                }</span>
                                <span class="cov0" title="0">e.log.Warn("trash failed", logger.F("path", item.Candidate.Path), logger.F("error", err.Error()))
                                e.metrics.IncDeleteErrors(reasonDeleteFailed)
                                res.Reason = reasonDeleteFailed
                                res.Err = err
                                return res</span>
                        }

                        <span class="cov0" title="0">e.log.Info("trashed", logger.F("path", item.Candidate.Path), logger.F("trash_path", trashPath), logger.F("bytes_freed", item.Candidate.SizeBytes))
                        e.metrics.IncFilesDeleted(item.Candidate.Root)
                        e.metrics.AddBytesFreed(item.Candidate.SizeBytes)
                        res.Deleted = true
                        res.BytesFreed = item.Candidate.SizeBytes
                        res.Reason = reasonTrashed
                        return res</span>
                }

                // Permanent delete
                <span class="cov8" title="1">if err := os.Remove(item.Candidate.Path); err != nil </span><span class="cov8" title="1">{
                        // Idempotent behavior: already removed is not fatal.
                        if errors.Is(err, os.ErrNotExist) </span><span class="cov8" title="1">{
                                res.Reason = reasonAlreadyGone
                                return res
                        }</span>
                        <span class="cov8" title="1">e.log.Warn("delete failed", logger.F("path", item.Candidate.Path), logger.F("error", err.Error()))
                        e.metrics.IncDeleteErrors(reasonDeleteFailed)
                        res.Reason = reasonDeleteFailed
                        res.Err = err
                        return res</span>
                }

                <span class="cov8" title="1">e.log.Info("deleted", logger.F("path", item.Candidate.Path), logger.F("bytes_freed", item.Candidate.SizeBytes))
                e.metrics.IncFilesDeleted(item.Candidate.Root)
                e.metrics.AddBytesFreed(item.Candidate.SizeBytes)
                res.Deleted = true
                res.BytesFreed = item.Candidate.SizeBytes
                res.Reason = reasonDeleted
                return res</span>

        case core.TargetDir:<span class="cov8" title="1">
                // Even in execute, dir deletion must be explicitly enabled.
                if !e.cfg.AllowDirDelete </span><span class="cov8" title="1">{
                        res.Reason = "dir_delete_disabled"
                        res.Err = core.ErrNotAllowed
                        return res
                }</span>

                // Calculate directory size before deletion.
                <span class="cov8" title="1">var dirSize int64
                _ = filepath.WalkDir(item.Candidate.Path, func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                        if err != nil || d.IsDir() </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">if info, err := d.Info(); err == nil </span><span class="cov8" title="1">{
                                dirSize += info.Size()
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                })

                // Try soft-delete first if trash is configured
                <span class="cov8" title="1">if e.trash != nil </span><span class="cov0" title="0">{
                        trashPath, err := e.trash.MoveToTrash(item.Candidate.Path)
                        if err != nil </span><span class="cov0" title="0">{
                                if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                                        res.Reason = reasonAlreadyGone
                                        return res
                                }</span>
                                <span class="cov0" title="0">e.log.Warn("trash failed", logger.F("path", item.Candidate.Path), logger.F("error", err.Error()))
                                e.metrics.IncDeleteErrors(reasonDeleteFailed)
                                res.Reason = reasonDeleteFailed
                                res.Err = err
                                return res</span>
                        }

                        <span class="cov0" title="0">e.log.Info("trashed", logger.F("path", item.Candidate.Path), logger.F("trash_path", trashPath), logger.F("bytes_freed", dirSize), logger.F("type", "dir"))
                        e.metrics.IncDirsDeleted(item.Candidate.Root)
                        e.metrics.AddBytesFreed(dirSize)
                        res.Deleted = true
                        res.BytesFreed = dirSize
                        res.Reason = reasonTrashed
                        return res</span>
                }

                // Permanent delete
                <span class="cov8" title="1">if err := os.RemoveAll(item.Candidate.Path); err != nil </span><span class="cov8" title="1">{
                        if errors.Is(err, os.ErrNotExist) </span><span class="cov0" title="0">{
                                res.Reason = reasonAlreadyGone
                                return res
                        }</span>
                        <span class="cov8" title="1">e.log.Warn("delete failed", logger.F("path", item.Candidate.Path), logger.F("error", err.Error()))
                        e.metrics.IncDeleteErrors(reasonDeleteFailed)
                        res.Reason = reasonDeleteFailed
                        res.Err = err
                        return res</span>
                }

                <span class="cov8" title="1">e.log.Info("deleted", logger.F("path", item.Candidate.Path), logger.F("bytes_freed", dirSize), logger.F("type", "dir"))
                e.metrics.IncDirsDeleted(item.Candidate.Root)
                e.metrics.AddBytesFreed(dirSize)
                res.Deleted = true
                res.BytesFreed = dirSize
                res.Reason = reasonDeleted
                return res</span>

        default:<span class="cov8" title="1">
                res.Reason = "unknown_target_type"
                res.Err = errors.New("unknown target type")
                return res</span>
        }
}

// record writes one audit event if an auditor is configured.
// It intentionally never panics and never blocks deletes if auditing fails.
func (e *Simple) record(ctx context.Context, item core.PlanItem, res core.ActionResult) <span class="cov8" title="1">{
        if e.aud == nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">evt := core.AuditEvent{
                Time:  res.FinishedAt,
                Level: "info",
                Action: func() string </span><span class="cov8" title="1">{
                        switch res.Reason </span>{
                        case reasonDeleted:<span class="cov8" title="1">
                                return "delete"</span>
                        case reasonWouldDelete:<span class="cov8" title="1">
                                return reasonWouldDelete</span>
                        default:<span class="cov8" title="1">
                                return "skip"</span>
                        }
                }(),
                Path: res.Path,
                Fields: map[string]any{
                        "mode":           string(res.Mode),
                        "type":           string(res.Type),
                        "deleted":        res.Deleted,
                        "bytes_freed":    res.BytesFreed,
                        "reason":         res.Reason,
                        "policy_reason":  item.Decision.Reason,
                        "safety_reason":  item.Safety.Reason,
                        "priority_score": item.Decision.Score, // &lt;-- the priority you asked for
                        "root":           item.Candidate.Root,
                },
                Err: res.Err,
        }

        // Best-effort: auditing must never break deletion.
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        e.log.Error("audit record panic recovered",
                                logger.F("panic", r),
                                logger.F("path", res.Path))
                }</span>
        }()
        <span class="cov8" title="1">e.aud.Record(ctx, evt)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package logger

import (
        "encoding/json"
        "fmt"
        "io"
        "os"
        "sync"
        "time"
)

// Level represents log severity levels.
type Level int

const (
        LevelDebug Level = iota
        LevelInfo
        LevelWarn
        LevelError
)

//nolint:goconst // Level string values are self-documenting in context
func (l Level) String() string <span class="cov8" title="1">{
        switch l </span>{
        case LevelDebug:<span class="cov8" title="1">
                return "debug"</span>
        case LevelInfo:<span class="cov8" title="1">
                return "info"</span>
        case LevelWarn:<span class="cov8" title="1">
                return "warn"</span>
        case LevelError:<span class="cov8" title="1">
                return "error"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// ParseLevel parses a string into a Level.
func ParseLevel(s string) (Level, error) <span class="cov8" title="1">{
        switch s </span>{
        case "debug":<span class="cov8" title="1">
                return LevelDebug, nil</span>
        case "info":<span class="cov8" title="1">
                return LevelInfo, nil</span>
        case "warn", "warning":<span class="cov8" title="1">
                return LevelWarn, nil</span>
        case "error":<span class="cov8" title="1">
                return LevelError, nil</span>
        default:<span class="cov8" title="1">
                return LevelInfo, fmt.Errorf("unknown log level: %s", s)</span>
        }
}

// Field represents a key-value pair for structured logging.
type Field struct {
        Key   string
        Value any
}

// F creates a new Field.
func F(key string, value any) Field <span class="cov8" title="1">{
        return Field{Key: key, Value: value}
}</span>

// Logger is the interface for structured logging.
type Logger interface {
        Debug(msg string, fields ...Field)
        Info(msg string, fields ...Field)
        Warn(msg string, fields ...Field)
        Error(msg string, fields ...Field)
        WithFields(fields ...Field) Logger
}

// JSONLogger implements Logger with JSON output.
type JSONLogger struct {
        mu     sync.Mutex
        level  Level
        output io.Writer
        fields []Field
}

// logEntry represents a single log entry.
type logEntry struct {
        Time    string         `json:"time"`
        Level   string         `json:"level"`
        Message string         `json:"msg"`
        Fields  map[string]any `json:"fields,omitempty"`
}

// New creates a new JSONLogger.
func New(level Level, output io.Writer) *JSONLogger <span class="cov8" title="1">{
        if output == nil </span><span class="cov8" title="1">{
                output = os.Stderr
        }</span>
        <span class="cov8" title="1">return &amp;JSONLogger{
                level:  level,
                output: output,
                fields: nil,
        }</span>
}

// NewDefault creates a logger with info level writing to stderr.
func NewDefault() *JSONLogger <span class="cov8" title="1">{
        return New(LevelInfo, os.Stderr)
}</span>

// Debug logs at debug level.
func (l *JSONLogger) Debug(msg string, fields ...Field) <span class="cov8" title="1">{
        l.log(LevelDebug, msg, fields)
}</span>

// Info logs at info level.
func (l *JSONLogger) Info(msg string, fields ...Field) <span class="cov8" title="1">{
        l.log(LevelInfo, msg, fields)
}</span>

// Warn logs at warn level.
func (l *JSONLogger) Warn(msg string, fields ...Field) <span class="cov8" title="1">{
        l.log(LevelWarn, msg, fields)
}</span>

// Error logs at error level.
func (l *JSONLogger) Error(msg string, fields ...Field) <span class="cov8" title="1">{
        l.log(LevelError, msg, fields)
}</span>

// WithFields returns a new logger with additional fields.
func (l *JSONLogger) WithFields(fields ...Field) Logger <span class="cov8" title="1">{
        newFields := make([]Field, len(l.fields)+len(fields))
        copy(newFields, l.fields)
        copy(newFields[len(l.fields):], fields)
        return &amp;JSONLogger{
                level:  l.level,
                output: l.output,
                fields: newFields,
        }
}</span>

func (l *JSONLogger) log(level Level, msg string, fields []Field) <span class="cov8" title="1">{
        if level &lt; l.level </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">entry := logEntry{
                Time:    time.Now().UTC().Format(time.RFC3339),
                Level:   level.String(),
                Message: msg,
        }

        // Merge base fields with call-specific fields
        allFields := append(l.fields, fields...)
        if len(allFields) &gt; 0 </span><span class="cov8" title="1">{
                entry.Fields = make(map[string]any, len(allFields))
                for _, f := range allFields </span><span class="cov8" title="1">{
                        entry.Fields[f.Key] = f.Value
                }</span>
        }

        <span class="cov8" title="1">l.mu.Lock()
        defer l.mu.Unlock()

        data, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to simple format if JSON fails
                _, _ = fmt.Fprintf(l.output, "%s [%s] %s\n", entry.Time, entry.Level, msg)
                return
        }</span>

        <span class="cov8" title="1">_, _ = l.output.Write(data)
        _, _ = l.output.Write([]byte("\n"))</span>
}

// SetLevel changes the log level.
func (l *JSONLogger) SetLevel(level Level) <span class="cov8" title="1">{
        l.mu.Lock()
        defer l.mu.Unlock()
        l.level = level
}</span>

// NopLogger is a logger that discards all output.
type NopLogger struct{}

func (NopLogger) Debug(msg string, fields ...Field) {<span class="cov8" title="1">}</span>
func (NopLogger) Info(msg string, fields ...Field)  {<span class="cov8" title="1">}</span>
func (NopLogger) Warn(msg string, fields ...Field)  {<span class="cov8" title="1">}</span>
func (NopLogger) Error(msg string, fields ...Field) {<span class="cov8" title="1">}</span>
func (NopLogger) WithFields(fields ...Field) Logger <span class="cov8" title="1">{ return NopLogger{} }</span>

// NewNop creates a no-op logger.
func NewNop() Logger <span class="cov8" title="1">{
        return NopLogger{}
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package logger

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "strconv"
        "sync"
        "time"
)

// LokiConfig holds configuration for Loki log shipping.
type LokiConfig struct {
        URL       string
        BatchSize int
        BatchWait time.Duration
        Labels    map[string]string
        TenantID  string
}

// lokiEntry represents a log entry to be sent to Loki.
type lokiEntry struct {
        Timestamp time.Time
        Level     string
        Message   string
        Fields    map[string]any
}

// lokiRequest is the JSON payload for Loki's push API.
type lokiRequest struct {
        Streams []lokiStream `json:"streams"`
}

// lokiStream represents a stream of log entries with labels.
type lokiStream struct {
        Stream map[string]string `json:"stream"`
        Values [][2]string       `json:"values"` // [[timestamp_ns, line], ...]
}

// LokiLogger wraps a base logger and ships logs to Loki.
type LokiLogger struct {
        base   Logger
        config LokiConfig
        client *http.Client

        mu       sync.Mutex
        buffer   []lokiEntry
        fields   []Field
        done     chan struct{}
        shutdown chan struct{}
        wg       sync.WaitGroup
        sendWg   sync.WaitGroup // tracks in-flight send() goroutines
}

// NewLokiLogger creates a new LokiLogger that wraps the base logger.
// Logs are sent to both the base logger and Loki asynchronously.
func NewLokiLogger(base Logger, cfg LokiConfig) *LokiLogger <span class="cov8" title="1">{
        if cfg.BatchSize &lt;= 0 </span><span class="cov8" title="1">{
                cfg.BatchSize = 100
        }</span>
        <span class="cov8" title="1">if cfg.BatchWait &lt;= 0 </span><span class="cov8" title="1">{
                cfg.BatchWait = 5 * time.Second
        }</span>
        <span class="cov8" title="1">if cfg.Labels == nil </span><span class="cov8" title="1">{
                cfg.Labels = map[string]string{"service": "storage-sage"}
        }</span>

        <span class="cov8" title="1">l := &amp;LokiLogger{
                base:   base,
                config: cfg,
                client: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
                buffer:   make([]lokiEntry, 0, cfg.BatchSize),
                done:     make(chan struct{}),
                shutdown: make(chan struct{}),
        }

        // Start background flusher
        l.wg.Add(1)
        go l.flusher()

        return l</span>
}

// Debug logs at debug level.
func (l *LokiLogger) Debug(msg string, fields ...Field) <span class="cov8" title="1">{
        l.base.Debug(msg, fields...)
        l.enqueue(LevelDebug, msg, fields)
}</span>

// Info logs at info level.
func (l *LokiLogger) Info(msg string, fields ...Field) <span class="cov8" title="1">{
        l.base.Info(msg, fields...)
        l.enqueue(LevelInfo, msg, fields)
}</span>

// Warn logs at warn level.
func (l *LokiLogger) Warn(msg string, fields ...Field) <span class="cov8" title="1">{
        l.base.Warn(msg, fields...)
        l.enqueue(LevelWarn, msg, fields)
}</span>

// Error logs at error level.
func (l *LokiLogger) Error(msg string, fields ...Field) <span class="cov8" title="1">{
        l.base.Error(msg, fields...)
        l.enqueue(LevelError, msg, fields)
}</span>

// WithFields returns a new logger with additional fields.
func (l *LokiLogger) WithFields(fields ...Field) Logger <span class="cov8" title="1">{
        newFields := make([]Field, len(l.fields)+len(fields))
        copy(newFields, l.fields)
        copy(newFields[len(l.fields):], fields)

        return &amp;LokiLogger{
                base:     l.base.WithFields(fields...),
                config:   l.config,
                client:   l.client,
                buffer:   l.buffer,
                fields:   newFields,
                done:     l.done,
                shutdown: l.shutdown,
        }
}</span>

// enqueue adds a log entry to the buffer.
func (l *LokiLogger) enqueue(level Level, msg string, fields []Field) <span class="cov8" title="1">{
        entry := lokiEntry{
                Timestamp: time.Now(),
                Level:     level.String(),
                Message:   msg,
        }

        // Merge base fields with call-specific fields
        allFields := append(l.fields, fields...)
        if len(allFields) &gt; 0 </span><span class="cov8" title="1">{
                entry.Fields = make(map[string]any, len(allFields))
                for _, f := range allFields </span><span class="cov8" title="1">{
                        entry.Fields[f.Key] = f.Value
                }</span>
        }

        <span class="cov8" title="1">l.mu.Lock()
        l.buffer = append(l.buffer, entry)
        shouldFlush := len(l.buffer) &gt;= l.config.BatchSize
        l.mu.Unlock()

        if shouldFlush </span><span class="cov8" title="1">{
                l.Flush()
        }</span>
}

// flusher runs in background and flushes buffer periodically.
func (l *LokiLogger) flusher() <span class="cov8" title="1">{
        defer l.wg.Done()

        ticker := time.NewTicker(l.config.BatchWait)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        l.Flush()</span>
                case &lt;-l.shutdown:<span class="cov8" title="1">
                        l.Flush() // Final flush
                        close(l.done)
                        return</span>
                }
        }
}

// Flush sends buffered logs to Loki.
func (l *LokiLogger) Flush() <span class="cov8" title="1">{
        l.mu.Lock()
        if len(l.buffer) == 0 </span><span class="cov8" title="1">{
                l.mu.Unlock()
                return
        }</span>

        // Swap buffer
        <span class="cov8" title="1">entries := l.buffer
        l.buffer = make([]lokiEntry, 0, l.config.BatchSize)
        l.mu.Unlock()

        // Send to Loki (non-blocking, errors logged to base logger)
        l.sendWg.Add(1)
        go func() </span><span class="cov8" title="1">{
                defer l.sendWg.Done()
                l.send(entries)
        }</span>()
}

// send pushes log entries to Loki.
func (l *LokiLogger) send(entries []lokiEntry) <span class="cov8" title="1">{
        if len(entries) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Build Loki request
        // Group entries by level for better label cardinality
        <span class="cov8" title="1">streams := make(map[string]*lokiStream)

        for _, entry := range entries </span><span class="cov8" title="1">{
                // Create stream key from level
                key := entry.Level

                stream, exists := streams[key]
                if !exists </span><span class="cov8" title="1">{
                        labels := make(map[string]string, len(l.config.Labels)+1)
                        for k, v := range l.config.Labels </span><span class="cov8" title="1">{
                                labels[k] = v
                        }</span>
                        <span class="cov8" title="1">labels["level"] = entry.Level
                        stream = &amp;lokiStream{
                                Stream: labels,
                                Values: make([][2]string, 0),
                        }
                        streams[key] = stream</span>
                }

                // Format log line as JSON
                <span class="cov8" title="1">line := l.formatLine(entry)
                timestamp := strconv.FormatInt(entry.Timestamp.UnixNano(), 10)
                stream.Values = append(stream.Values, [2]string{timestamp, line})</span>
        }

        // Convert map to slice
        <span class="cov8" title="1">streamSlice := make([]lokiStream, 0, len(streams))
        for _, s := range streams </span><span class="cov8" title="1">{
                streamSlice = append(streamSlice, *s)
        }</span>

        <span class="cov8" title="1">req := lokiRequest{Streams: streamSlice}

        // Marshal and send
        body, err := json.Marshal(req)
        if err != nil </span><span class="cov0" title="0">{
                l.base.Error("loki: failed to marshal request", F("error", err.Error()))
                return
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        httpReq, err := http.NewRequestWithContext(ctx, "POST", l.config.URL+"/loki/api/v1/push", bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                l.base.Error("loki: failed to create request", F("error", err.Error()))
                return
        }</span>

        <span class="cov8" title="1">httpReq.Header.Set("Content-Type", "application/json")
        if l.config.TenantID != "" </span><span class="cov8" title="1">{
                httpReq.Header.Set("X-Scope-OrgID", l.config.TenantID)
        }</span>

        <span class="cov8" title="1">resp, err := l.client.Do(httpReq)
        if err != nil </span><span class="cov8" title="1">{
                l.base.Error("loki: failed to send logs", F("error", err.Error()), F("entries", len(entries)))
                return
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                l.base.Error("loki: server error",
                        F("status", resp.StatusCode),
                        F("entries", len(entries)),
                )
        }</span>
}

// formatLine formats a log entry as a JSON string for Loki.
func (l *LokiLogger) formatLine(entry lokiEntry) string <span class="cov8" title="1">{
        line := map[string]any{
                "msg": entry.Message,
        }
        for k, v := range entry.Fields </span><span class="cov8" title="1">{
                line[k] = v
        }</span>

        <span class="cov8" title="1">data, err := json.Marshal(line)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf(`{"msg":%q,"error":"marshal_failed"}`, entry.Message)
        }</span>
        <span class="cov8" title="1">return string(data)</span>
}

// Close shuts down the Loki logger and flushes remaining logs.
func (l *LokiLogger) Close() error <span class="cov8" title="1">{
        close(l.shutdown)

        // Wait for flusher and in-flight sends to finish with timeout
        done := make(chan struct{})
        go func() </span><span class="cov8" title="1">{
                l.wg.Wait()     // Wait for flusher
                l.sendWg.Wait() // Wait for in-flight sends
                close(done)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case &lt;-done:<span class="cov8" title="1">
                return nil</span>
        case &lt;-time.After(10 * time.Second):<span class="cov0" title="0">
                return fmt.Errorf("loki: shutdown timed out")</span>
        }
}

// WaitForSends blocks until all in-flight send operations complete.
// Useful for testing to ensure sends finish before assertions.
func (l *LokiLogger) WaitForSends() <span class="cov8" title="1">{
        l.sendWg.Wait()
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package metrics

import (
        "time"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

// Noop is a no-op implementation of core.Metrics.
// Use this when metrics collection is disabled.
type Noop struct{}

// NewNoop creates a new no-op metrics collector.
func NewNoop() *Noop <span class="cov0" title="0">{
        return &amp;Noop{}
}</span>

// Scanning metrics
func (Noop) IncFilesScanned(string)                    {<span class="cov0" title="0">}</span>
func (Noop) IncDirsScanned(string)                     {<span class="cov0" title="0">}</span>
func (Noop) ObserveScanDuration(string, time.Duration) {<span class="cov0" title="0">}</span>

// Planning metrics
func (Noop) IncPolicyDecision(string, bool) {<span class="cov0" title="0">}</span>
func (Noop) IncSafetyVerdict(string, bool)  {<span class="cov0" title="0">}</span>
func (Noop) SetBytesEligible(int64)         {<span class="cov0" title="0">}</span>
func (Noop) SetFilesEligible(int)           {<span class="cov0" title="0">}</span>

// Execution metrics
func (Noop) IncFilesDeleted(string) {<span class="cov0" title="0">}</span>
func (Noop) IncDirsDeleted(string)  {<span class="cov0" title="0">}</span>
func (Noop) AddBytesFreed(int64)    {<span class="cov0" title="0">}</span>
func (Noop) IncDeleteErrors(string) {<span class="cov0" title="0">}</span>

// System metrics
func (Noop) SetDiskUsage(float64) {<span class="cov0" title="0">}</span>
func (Noop) SetCPUUsage(float64)  {<span class="cov0" title="0">}</span>

// Daemon metrics
func (Noop) SetLastRunTimestamp(time.Time) {<span class="cov0" title="0">}</span>

// Ensure Noop implements core.Metrics
var _ core.Metrics = (*Noop)(nil)
</pre>
		
		<pre class="file" id="file19" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "github.com/prometheus/client_golang/prometheus/promauto"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

// Prometheus implements core.Metrics using Prometheus client.
type Prometheus struct {
        // Scanning metrics
        filesScanned *prometheus.CounterVec
        dirsScanned  *prometheus.CounterVec
        scanDuration *prometheus.HistogramVec

        // Planning metrics
        policyDecisions *prometheus.CounterVec
        safetyVerdicts  *prometheus.CounterVec
        bytesEligible   prometheus.Gauge
        filesEligible   prometheus.Gauge

        // Execution metrics
        filesDeleted *prometheus.CounterVec
        dirsDeleted  *prometheus.CounterVec
        bytesFreed   prometheus.Counter
        deleteErrors *prometheus.CounterVec

        // System metrics
        diskUsage prometheus.Gauge
        cpuUsage  prometheus.Gauge

        // Daemon metrics
        lastRunTimestamp prometheus.Gauge
}

// NewPrometheus creates a new Prometheus metrics collector.
// All metrics are registered with the provided registry.
// If reg is nil, prometheus.DefaultRegisterer is used.
func NewPrometheus(reg prometheus.Registerer) *Prometheus <span class="cov8" title="1">{
        if reg == nil </span><span class="cov8" title="1">{
                reg = prometheus.DefaultRegisterer
        }</span>

        <span class="cov8" title="1">factory := promauto.With(reg)

        return &amp;Prometheus{
                // Scanning metrics
                filesScanned: factory.NewCounterVec(prometheus.CounterOpts{
                        Namespace: "storagesage",
                        Subsystem: "scanner",
                        Name:      "files_scanned_total",
                        Help:      "Total number of files scanned",
                }, []string{"root"}),

                dirsScanned: factory.NewCounterVec(prometheus.CounterOpts{
                        Namespace: "storagesage",
                        Subsystem: "scanner",
                        Name:      "dirs_scanned_total",
                        Help:      "Total number of directories scanned",
                }, []string{"root"}),

                scanDuration: factory.NewHistogramVec(prometheus.HistogramOpts{
                        Namespace: "storagesage",
                        Subsystem: "scanner",
                        Name:      "scan_duration_seconds",
                        Help:      "Time spent scanning roots",
                        Buckets:   prometheus.ExponentialBuckets(0.1, 2, 10), // 0.1s to ~100s
                }, []string{"root"}),

                // Planning metrics
                policyDecisions: factory.NewCounterVec(prometheus.CounterOpts{
                        Namespace: "storagesage",
                        Subsystem: "planner",
                        Name:      "policy_decisions_total",
                        Help:      "Total policy decisions by reason and outcome",
                }, []string{"reason", "allowed"}),

                safetyVerdicts: factory.NewCounterVec(prometheus.CounterOpts{
                        Namespace: "storagesage",
                        Subsystem: "planner",
                        Name:      "safety_verdicts_total",
                        Help:      "Total safety verdicts by reason and outcome",
                }, []string{"reason", "allowed"}),

                bytesEligible: factory.NewGauge(prometheus.GaugeOpts{
                        Namespace: "storagesage",
                        Subsystem: "planner",
                        Name:      "bytes_eligible",
                        Help:      "Total bytes eligible for deletion in current plan",
                }),

                filesEligible: factory.NewGauge(prometheus.GaugeOpts{
                        Namespace: "storagesage",
                        Subsystem: "planner",
                        Name:      "files_eligible",
                        Help:      "Total files eligible for deletion in current plan",
                }),

                // Execution metrics
                filesDeleted: factory.NewCounterVec(prometheus.CounterOpts{
                        Namespace: "storagesage",
                        Subsystem: "executor",
                        Name:      "files_deleted_total",
                        Help:      "Total number of files deleted",
                }, []string{"root"}),

                dirsDeleted: factory.NewCounterVec(prometheus.CounterOpts{
                        Namespace: "storagesage",
                        Subsystem: "executor",
                        Name:      "dirs_deleted_total",
                        Help:      "Total number of directories deleted",
                }, []string{"root"}),

                bytesFreed: factory.NewCounter(prometheus.CounterOpts{
                        Namespace: "storagesage",
                        Subsystem: "executor",
                        Name:      "bytes_freed_total",
                        Help:      "Total bytes freed by deletions",
                }),

                deleteErrors: factory.NewCounterVec(prometheus.CounterOpts{
                        Namespace: "storagesage",
                        Subsystem: "executor",
                        Name:      "delete_errors_total",
                        Help:      "Total delete errors by reason",
                }, []string{"reason"}),

                // System metrics
                diskUsage: factory.NewGauge(prometheus.GaugeOpts{
                        Namespace: "storagesage",
                        Subsystem: "system",
                        Name:      "disk_usage_percent",
                        Help:      "Current disk usage percentage",
                }),

                cpuUsage: factory.NewGauge(prometheus.GaugeOpts{
                        Namespace: "storagesage",
                        Subsystem: "system",
                        Name:      "cpu_usage_percent",
                        Help:      "Current CPU usage percentage",
                }),

                // Daemon metrics
                lastRunTimestamp: factory.NewGauge(prometheus.GaugeOpts{
                        Namespace: "storagesage",
                        Subsystem: "daemon",
                        Name:      "last_run_timestamp_seconds",
                        Help:      "Unix timestamp of the last successful cleanup run",
                }),
        }</span>
}

// Scanning metrics

func (p *Prometheus) IncFilesScanned(root string) <span class="cov8" title="1">{
        p.filesScanned.WithLabelValues(root).Inc()
}</span>

func (p *Prometheus) IncDirsScanned(root string) <span class="cov8" title="1">{
        p.dirsScanned.WithLabelValues(root).Inc()
}</span>

func (p *Prometheus) ObserveScanDuration(root string, duration time.Duration) <span class="cov8" title="1">{
        p.scanDuration.WithLabelValues(root).Observe(duration.Seconds())
}</span>

// Planning metrics

func (p *Prometheus) IncPolicyDecision(reason string, allowed bool) <span class="cov8" title="1">{
        p.policyDecisions.WithLabelValues(reason, boolStr(allowed)).Inc()
}</span>

func (p *Prometheus) IncSafetyVerdict(reason string, allowed bool) <span class="cov8" title="1">{
        p.safetyVerdicts.WithLabelValues(reason, boolStr(allowed)).Inc()
}</span>

func (p *Prometheus) SetBytesEligible(bytes int64) <span class="cov8" title="1">{
        p.bytesEligible.Set(float64(bytes))
}</span>

func (p *Prometheus) SetFilesEligible(count int) <span class="cov8" title="1">{
        p.filesEligible.Set(float64(count))
}</span>

// Execution metrics

func (p *Prometheus) IncFilesDeleted(root string) <span class="cov8" title="1">{
        p.filesDeleted.WithLabelValues(root).Inc()
}</span>

func (p *Prometheus) IncDirsDeleted(root string) <span class="cov8" title="1">{
        p.dirsDeleted.WithLabelValues(root).Inc()
}</span>

func (p *Prometheus) AddBytesFreed(bytes int64) <span class="cov8" title="1">{
        p.bytesFreed.Add(float64(bytes))
}</span>

func (p *Prometheus) IncDeleteErrors(reason string) <span class="cov8" title="1">{
        p.deleteErrors.WithLabelValues(reason).Inc()
}</span>

// System metrics

func (p *Prometheus) SetDiskUsage(percent float64) <span class="cov8" title="1">{
        p.diskUsage.Set(percent)
}</span>

func (p *Prometheus) SetCPUUsage(percent float64) <span class="cov8" title="1">{
        p.cpuUsage.Set(percent)
}</span>

// Daemon metrics

func (p *Prometheus) SetLastRunTimestamp(t time.Time) <span class="cov0" title="0">{
        p.lastRunTimestamp.Set(float64(t.Unix()))
}</span>

func boolStr(b bool) string <span class="cov8" title="1">{
        if b </span><span class="cov8" title="1">{
                return "true"
        }</span>
        <span class="cov8" title="1">return "false"</span>
}

// Ensure Prometheus implements core.Metrics
var _ core.Metrics = (*Prometheus)(nil)
</pre>
		
		<pre class="file" id="file20" style="display: none">package metrics

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/prometheus/client_golang/prometheus/promhttp"
)

// Server serves Prometheus metrics over HTTP.
type Server struct {
        addr   string
        server *http.Server
}

// NewServer creates a metrics server listening on the given address.
// Default address is ":9090" if addr is empty.
func NewServer(addr string) *Server <span class="cov8" title="1">{
        if addr == "" </span><span class="cov8" title="1">{
                addr = ":9090"
        }</span>

        <span class="cov8" title="1">mux := http.NewServeMux()
        mux.Handle("/metrics", promhttp.Handler())
        mux.HandleFunc("/health", func(w http.ResponseWriter, _ *http.Request) </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusOK)
                _, _ = fmt.Fprintln(w, "ok")
        }</span>)

        <span class="cov8" title="1">return &amp;Server{
                addr: addr,
                server: &amp;http.Server{
                        Addr:              addr,
                        Handler:           mux,
                        ReadHeaderTimeout: 10 * time.Second,
                },
        }</span>
}

// Start begins serving metrics. It blocks until the server stops.
// Returns nil if stopped via Shutdown, otherwise returns the error.
func (s *Server) Start() error <span class="cov8" title="1">{
        err := s.server.ListenAndServe()
        if err == http.ErrServerClosed </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Shutdown gracefully stops the metrics server.
func (s *Server) Shutdown(ctx context.Context) error <span class="cov8" title="1">{
        return s.server.Shutdown(ctx)
}</span>

// Addr returns the address the server is configured to listen on.
func (s *Server) Addr() string <span class="cov8" title="1">{
        return s.addr
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package notifier

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"
)

// Event types for notifications
type EventType string

const (
        EventCleanupStarted   EventType = "cleanup_started"
        EventCleanupCompleted EventType = "cleanup_completed"
        EventCleanupFailed    EventType = "cleanup_failed"
        EventDaemonStarted    EventType = "daemon_started"
        EventDaemonStopped    EventType = "daemon_stopped"
)

// CleanupSummary contains statistics from a cleanup run
type CleanupSummary struct {
        Root          string    `json:"root"`
        Mode          string    `json:"mode"`
        FilesScanned  int       `json:"files_scanned"`
        FilesDeleted  int       `json:"files_deleted"`
        BytesFreed    int64     `json:"bytes_freed"`
        Errors        int       `json:"errors"`
        Duration      string    `json:"duration"`
        StartedAt     time.Time `json:"started_at"`
        CompletedAt   time.Time `json:"completed_at"`
        ErrorMessages []string  `json:"error_messages,omitempty"`
}

// WebhookPayload is the JSON payload sent to webhook endpoints
type WebhookPayload struct {
        Event     EventType       `json:"event"`
        Timestamp time.Time       `json:"timestamp"`
        Hostname  string          `json:"hostname,omitempty"`
        Summary   *CleanupSummary `json:"summary,omitempty"`
        Message   string          `json:"message,omitempty"`
}

// WebhookConfig configures a webhook notification endpoint
type WebhookConfig struct {
        URL     string            `yaml:"url"`
        Headers map[string]string `yaml:"headers,omitempty"`
        Events  []EventType       `yaml:"events,omitempty"` // Empty = all events
        Timeout time.Duration     `yaml:"timeout,omitempty"`
}

// Webhook sends notifications to HTTP endpoints
type Webhook struct {
        config WebhookConfig
        client *http.Client
}

// NewWebhook creates a new webhook notifier
func NewWebhook(cfg WebhookConfig) *Webhook <span class="cov8" title="1">{
        timeout := cfg.Timeout
        if timeout == 0 </span><span class="cov8" title="1">{
                timeout = 10 * time.Second
        }</span>

        <span class="cov8" title="1">return &amp;Webhook{
                config: cfg,
                client: &amp;http.Client{Timeout: timeout},
        }</span>
}

// Notify sends a notification to the webhook endpoint
func (w *Webhook) Notify(ctx context.Context, payload WebhookPayload) error <span class="cov8" title="1">{
        // Check if we should send this event type
        if !w.shouldNotify(payload.Event) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">body, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("marshal payload: %w", err)
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequestWithContext(ctx, http.MethodPost, w.config.URL, bytes.NewReader(body))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("create request: %w", err)
        }</span>

        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")
        req.Header.Set("User-Agent", "storage-sage/1.0")

        // Add custom headers
        for k, v := range w.config.Headers </span><span class="cov8" title="1">{
                req.Header.Set(k, v)
        }</span>

        <span class="cov8" title="1">resp, err := w.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("send request: %w", err)
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode &gt;= 400 </span><span class="cov8" title="1">{
                return fmt.Errorf("webhook returned status %d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (w *Webhook) shouldNotify(event EventType) bool <span class="cov8" title="1">{
        // Empty events list means notify for all events
        if len(w.config.Events) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">for _, e := range w.config.Events </span><span class="cov8" title="1">{
                if e == event </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Notifier is the interface for sending notifications
type Notifier interface {
        Notify(ctx context.Context, payload WebhookPayload) error
}

// MultiNotifier sends notifications to multiple endpoints
type MultiNotifier struct {
        mu        sync.RWMutex
        notifiers []Notifier
}

// NewMultiNotifier creates a notifier that sends to multiple endpoints
func NewMultiNotifier(notifiers ...Notifier) *MultiNotifier <span class="cov8" title="1">{
        return &amp;MultiNotifier{notifiers: notifiers}
}</span>

// Notify sends to all configured notifiers, collecting errors
func (m *MultiNotifier) Notify(ctx context.Context, payload WebhookPayload) error <span class="cov8" title="1">{
        m.mu.RLock()
        notifiers := make([]Notifier, len(m.notifiers))
        copy(notifiers, m.notifiers)
        m.mu.RUnlock()

        var errs []error
        for _, n := range notifiers </span><span class="cov8" title="1">{
                if err := n.Notify(ctx, payload); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, err)
                }</span>
        }

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("notification errors: %v", errs)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Add adds a notifier to the multi-notifier
func (m *MultiNotifier) Add(n Notifier) <span class="cov0" title="0">{
        m.mu.Lock()
        m.notifiers = append(m.notifiers, n)
        m.mu.Unlock()
}</span>

// NoopNotifier does nothing (for when notifications are disabled)
type NoopNotifier struct{}

func (n *NoopNotifier) Notify(ctx context.Context, payload WebhookPayload) error <span class="cov0" title="0">{
        return nil
}</span>

// SlackPayload formats a webhook payload for Slack
func SlackPayload(payload WebhookPayload) map[string]interface{} <span class="cov8" title="1">{
        var color, title string
        switch payload.Event </span>{
        case EventCleanupCompleted:<span class="cov8" title="1">
                if payload.Summary != nil &amp;&amp; payload.Summary.Errors &gt; 0 </span><span class="cov8" title="1">{
                        color = "warning"
                        title = "Storage-Sage Cleanup Completed with Errors"
                }</span> else<span class="cov8" title="1"> {
                        color = "good"
                        title = "Storage-Sage Cleanup Completed"
                }</span>
        case EventCleanupFailed:<span class="cov0" title="0">
                color = "danger"
                title = "Storage-Sage Cleanup Failed"</span>
        case EventCleanupStarted:<span class="cov0" title="0">
                color = "#439FE0"
                title = "Storage-Sage Cleanup Started"</span>
        default:<span class="cov0" title="0">
                color = "#808080"
                title = fmt.Sprintf("Storage-Sage: %s", payload.Event)</span>
        }

        <span class="cov8" title="1">fields := []map[string]interface{}{}

        if payload.Summary != nil </span><span class="cov8" title="1">{
                fields = append(fields,
                        map[string]interface{}{"title": "Root", "value": payload.Summary.Root, "short": true},
                        map[string]interface{}{"title": "Mode", "value": payload.Summary.Mode, "short": true},
                        map[string]interface{}{"title": "Files Deleted", "value": fmt.Sprintf("%d", payload.Summary.FilesDeleted), "short": true},
                        map[string]interface{}{"title": "Bytes Freed", "value": formatBytes(payload.Summary.BytesFreed), "short": true},
                        map[string]interface{}{"title": "Duration", "value": payload.Summary.Duration, "short": true},
                )
                if payload.Summary.Errors &gt; 0 </span><span class="cov8" title="1">{
                        fields = append(fields,
                                map[string]interface{}{"title": "Errors", "value": fmt.Sprintf("%d", payload.Summary.Errors), "short": true},
                        )
                }</span>
        }

        <span class="cov8" title="1">return map[string]interface{}{
                "attachments": []map[string]interface{}{
                        {
                                "color":  color,
                                "title":  title,
                                "text":   payload.Message,
                                "fields": fields,
                                "footer": "storage-sage",
                                "ts":     payload.Timestamp.Unix(),
                        },
                },
        }</span>
}

func formatBytes(b int64) string <span class="cov8" title="1">{
        const unit = 1024
        if b &lt; unit </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d B", b)
        }</span>
        <span class="cov8" title="1">div, exp := int64(unit), 0
        for n := b / unit; n &gt;= unit; n /= unit </span><span class="cov8" title="1">{
                div *= unit
                exp++
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.1f %cB", float64(b)/float64(div), "KMGTPE"[exp])</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">//go:build unix

// Package pidfile provides PID file management with flock-based locking
// to prevent multiple daemon instances from running simultaneously.
package pidfile

import (
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "syscall"
)

// PIDFile manages a PID file with exclusive locking.
type PIDFile struct {
        path string
        file *os.File
}

// New creates and locks a PID file at the given path.
// Returns an error if another process already holds the lock.
func New(path string) (*PIDFile, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return nil, nil // No PID file requested
        }</span>

        // Ensure parent directory exists
        <span class="cov8" title="1">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating pid directory: %w", err)
        }</span>

        // Open or create the PID file
        <span class="cov8" title="1">file, err := os.OpenFile(path, os.O_CREATE|os.O_RDWR, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("opening pid file: %w", err)
        }</span>

        // Try to acquire an exclusive lock (non-blocking)
        <span class="cov8" title="1">if err := syscall.Flock(int(file.Fd()), syscall.LOCK_EX|syscall.LOCK_NB); err != nil </span><span class="cov8" title="1">{
                file.Close()

                // Try to read the existing PID for a better error message
                existingPID := "unknown"
                if data, readErr := os.ReadFile(path); readErr == nil </span><span class="cov8" title="1">{
                        existingPID = string(data)
                }</span>

                <span class="cov8" title="1">return nil, fmt.Errorf("another instance is running (pid: %s): %w", existingPID, err)</span>
        }

        // Truncate and write our PID
        <span class="cov8" title="1">if err := file.Truncate(0); err != nil </span><span class="cov0" title="0">{
                file.Close()
                return nil, fmt.Errorf("truncating pid file: %w", err)
        }</span>

        <span class="cov8" title="1">if _, err := file.Seek(0, 0); err != nil </span><span class="cov0" title="0">{
                file.Close()
                return nil, fmt.Errorf("seeking pid file: %w", err)
        }</span>

        <span class="cov8" title="1">pid := os.Getpid()
        if _, err := fmt.Fprintf(file, "%d\n", pid); err != nil </span><span class="cov0" title="0">{
                file.Close()
                return nil, fmt.Errorf("writing pid: %w", err)
        }</span>

        // Sync to disk
        <span class="cov8" title="1">if err := file.Sync(); err != nil </span><span class="cov0" title="0">{
                file.Close()
                return nil, fmt.Errorf("syncing pid file: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;PIDFile{
                path: path,
                file: file,
        }, nil</span>
}

// Close releases the lock and removes the PID file.
func (p *PIDFile) Close() error <span class="cov8" title="1">{
        if p == nil || p.file == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Release the lock
        <span class="cov8" title="1">_ = syscall.Flock(int(p.file.Fd()), syscall.LOCK_UN)

        // Close the file
        if err := p.file.Close(); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("closing pid file: %w", err)
        }</span>

        // Remove the file
        <span class="cov8" title="1">if err := os.Remove(p.path); err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return fmt.Errorf("removing pid file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Path returns the PID file path.
func (p *PIDFile) Path() string <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return p.path</span>
}

// ReadPID reads the PID from an existing PID file (for status checks).
func ReadPID(path string) (int, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        // Trim whitespace and parse
        <span class="cov8" title="1">pidStr := string(data)
        for len(pidStr) &gt; 0 &amp;&amp; (pidStr[len(pidStr)-1] == '\n' || pidStr[len(pidStr)-1] == '\r') </span><span class="cov8" title="1">{
                pidStr = pidStr[:len(pidStr)-1]
        }</span>

        <span class="cov8" title="1">pid, err := strconv.Atoi(pidStr)
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("invalid pid in file: %w", err)
        }</span>

        <span class="cov8" title="1">return pid, nil</span>
}

// IsRunning checks if a process with the given PID is still running.
func IsRunning(pid int) bool <span class="cov8" title="1">{
        process, err := os.FindProcess(pid)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // On Unix, FindProcess always succeeds. Send signal 0 to check if process exists.
        <span class="cov8" title="1">err = process.Signal(syscall.Signal(0))
        return err == nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package planner

import (
        "context"
        "sort"

        "github.com/ChrisB0-2/storage-sage/internal/core"
        "github.com/ChrisB0-2/storage-sage/internal/logger"
        "github.com/ChrisB0-2/storage-sage/internal/metrics"
)

type Simple struct {
        log     logger.Logger
        metrics core.Metrics
}

// NewSimple creates a planner with no-op logging and metrics.
func NewSimple() *Simple <span class="cov8" title="1">{
        return &amp;Simple{
                log:     logger.NewNop(),
                metrics: metrics.NewNoop(),
        }
}</span>

// NewSimpleWithLogger creates a planner with the given logger.
func NewSimpleWithLogger(log logger.Logger) *Simple <span class="cov0" title="0">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.NewNop()
        }</span>
        <span class="cov0" title="0">return &amp;Simple{
                log:     log,
                metrics: metrics.NewNoop(),
        }</span>
}

// NewSimpleWithMetrics creates a planner with logger and metrics.
func NewSimpleWithMetrics(log logger.Logger, m core.Metrics) *Simple <span class="cov0" title="0">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.NewNop()
        }</span>
        <span class="cov0" title="0">if m == nil </span><span class="cov0" title="0">{
                m = metrics.NewNoop()
        }</span>
        <span class="cov0" title="0">return &amp;Simple{
                log:     log,
                metrics: m,
        }</span>
}

func (p *Simple) BuildPlan(
        ctx context.Context,
        in &lt;-chan core.Candidate,
        pol core.Policy,
        safe core.Safety,
        env core.EnvSnapshot,
        cfg core.SafetyConfig,
) ([]core.PlanItem, error) <span class="cov8" title="1">{
        p.log.Debug("building plan")
        var items []core.PlanItem

        for cand := range in </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return nil, ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">dec := pol.Evaluate(ctx, cand, env)
                verdict := safe.Validate(ctx, cand, cfg)

                // Record metrics
                p.metrics.IncPolicyDecision(dec.Reason, dec.Allow)
                p.metrics.IncSafetyVerdict(verdict.Reason, verdict.Allowed)

                items = append(items, core.PlanItem{
                        Candidate: cand,
                        Decision:  dec,
                        Safety:    verdict,
                })</span>
        }

        <span class="cov8" title="1">sort.Slice(items, func(i, j int) bool </span><span class="cov8" title="1">{
                return items[i].Candidate.Path &lt; items[j].Candidate.Path
        }</span>)

        // Calculate and record eligible files/bytes
        <span class="cov8" title="1">var eligibleFiles int
        var eligibleBytes int64
        for _, item := range items </span><span class="cov8" title="1">{
                if item.Decision.Allow &amp;&amp; item.Safety.Allowed &amp;&amp; item.Candidate.Type == core.TargetFile </span><span class="cov8" title="1">{
                        eligibleFiles++
                        eligibleBytes += item.Candidate.SizeBytes
                }</span>
        }
        <span class="cov8" title="1">p.metrics.SetFilesEligible(eligibleFiles)
        p.metrics.SetBytesEligible(eligibleBytes)

        p.log.Info("plan built", logger.F("items", len(items)))
        return items, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package policy

import (
        "context"
        "time"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

type AgePolicy struct {
        MinAge time.Duration
}

func NewAgePolicy(minAgeDays int) *AgePolicy <span class="cov8" title="1">{
        return &amp;AgePolicy{MinAge: time.Duration(minAgeDays) * 24 * time.Hour}
}</span>

func (p *AgePolicy) Evaluate(_ context.Context, c core.Candidate, env core.EnvSnapshot) core.Decision <span class="cov8" title="1">{
        age := env.Now.Sub(c.ModTime)
        if age &lt; 0 </span><span class="cov8" title="1">{
                age = 0
        }</span>

        <span class="cov8" title="1">ageDays := int(age / (24 * time.Hour))
        if ageDays &lt; 0 </span><span class="cov0" title="0">{
                ageDays = 0
        }</span>
        <span class="cov8" title="1">if ageDays &gt; 3650 </span><span class="cov0" title="0">{
                ageDays = 3650
        }</span>

        <span class="cov8" title="1">sizeMiB := int(c.SizeBytes / (1024 * 1024))
        if sizeMiB &lt; 0 </span><span class="cov0" title="0">{
                sizeMiB = 0
        }</span>
        <span class="cov8" title="1">if sizeMiB &gt; 1024 </span><span class="cov0" title="0">{
                sizeMiB = 1024
        }</span>

        // Priority score: age dominates; size is a small tie-breaker.
        <span class="cov8" title="1">score := ageDays*10 + sizeMiB

        if age &gt;= p.MinAge </span><span class="cov8" title="1">{
                return core.Decision{Allow: true, Reason: "age_ok", Score: score}
        }</span>
        <span class="cov8" title="1">return core.Decision{Allow: false, Reason: "too_new", Score: 0}</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package policy

import (
        "context"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

// CompositeMode determines how multiple policies are combined.
type CompositeMode string

const (
        // ModeAnd requires all policies to allow (logical AND).
        ModeAnd CompositeMode = "and"
        // ModeOr requires at least one policy to allow (logical OR).
        ModeOr CompositeMode = "or"
)

// CompositePolicy combines multiple policies with AND or OR logic.
type CompositePolicy struct {
        Policies []core.Policy
        Mode     CompositeMode
}

// NewCompositePolicy creates a policy that combines multiple policies.
// Mode "and" requires all to allow; mode "or" requires at least one to allow.
func NewCompositePolicy(mode CompositeMode, policies ...core.Policy) *CompositePolicy <span class="cov8" title="1">{
        return &amp;CompositePolicy{
                Policies: policies,
                Mode:     mode,
        }
}</span>

func (p *CompositePolicy) Evaluate(ctx context.Context, c core.Candidate, env core.EnvSnapshot) core.Decision <span class="cov8" title="1">{
        if len(p.Policies) == 0 </span><span class="cov8" title="1">{
                return core.Decision{Allow: false, Reason: "no_policies", Score: 0}
        }</span>

        <span class="cov8" title="1">switch p.Mode </span>{
        case ModeAnd:<span class="cov8" title="1">
                return p.evaluateAnd(ctx, c, env)</span>
        case ModeOr:<span class="cov8" title="1">
                return p.evaluateOr(ctx, c, env)</span>
        default:<span class="cov0" title="0">
                return core.Decision{Allow: false, Reason: "invalid_mode", Score: 0}</span>
        }
}

// evaluateAnd returns allow only if ALL policies allow.
// Returns the minimum score and first deny reason encountered.
func (p *CompositePolicy) evaluateAnd(ctx context.Context, c core.Candidate, env core.EnvSnapshot) core.Decision <span class="cov8" title="1">{
        minScore := int(^uint(0) &gt;&gt; 1) // Max int

        for _, pol := range p.Policies </span><span class="cov8" title="1">{
                dec := pol.Evaluate(ctx, c, env)
                if !dec.Allow </span><span class="cov8" title="1">{
                        return core.Decision{
                                Allow:  false,
                                Reason: "and_deny:" + dec.Reason,
                                Score:  0,
                        }
                }</span>
                <span class="cov8" title="1">if dec.Score &lt; minScore </span><span class="cov8" title="1">{
                        minScore = dec.Score
                }</span>
        }

        <span class="cov8" title="1">return core.Decision{
                Allow:  true,
                Reason: "and_allow",
                Score:  minScore,
        }</span>
}

// evaluateOr returns allow if ANY policy allows.
// Returns the maximum score among allowing policies.
func (p *CompositePolicy) evaluateOr(ctx context.Context, c core.Candidate, env core.EnvSnapshot) core.Decision <span class="cov8" title="1">{
        maxScore := 0
        var allowReason string
        denyReasons := make([]string, 0, len(p.Policies))

        for _, pol := range p.Policies </span><span class="cov8" title="1">{
                dec := pol.Evaluate(ctx, c, env)
                if dec.Allow </span><span class="cov8" title="1">{
                        if dec.Score &gt; maxScore </span><span class="cov8" title="1">{
                                maxScore = dec.Score
                                allowReason = dec.Reason
                        }</span>
                } else<span class="cov8" title="1"> {
                        denyReasons = append(denyReasons, dec.Reason)
                }</span>
        }

        <span class="cov8" title="1">if allowReason != "" </span><span class="cov8" title="1">{
                return core.Decision{
                        Allow:  true,
                        Reason: "or_allow:" + allowReason,
                        Score:  maxScore,
                }
        }</span>

        // All denied - return first deny reason
        <span class="cov8" title="1">reason := "or_deny"
        if len(denyReasons) &gt; 0 </span><span class="cov8" title="1">{
                reason = "or_deny:" + denyReasons[0]
        }</span>
        <span class="cov8" title="1">return core.Decision{
                Allow:  false,
                Reason: reason,
                Score:  0,
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package policy

import (
        "context"
        "path/filepath"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

// ExclusionPolicy denies deletion of files matching any exclusion pattern.
// Patterns use filepath.Match syntax (e.g., "*.important", "keep-*", "backup/**").
type ExclusionPolicy struct {
        patterns []string
}

// NewExclusionPolicy creates a policy that blocks files matching any pattern.
// Empty patterns slice means nothing is excluded (all files allowed).
func NewExclusionPolicy(patterns []string) *ExclusionPolicy <span class="cov8" title="1">{
        return &amp;ExclusionPolicy{patterns: patterns}
}</span>

func (p *ExclusionPolicy) Evaluate(ctx context.Context, c core.Candidate, env core.EnvSnapshot) core.Decision <span class="cov8" title="1">{
        if len(p.patterns) == 0 </span><span class="cov8" title="1">{
                return core.Decision{Allow: true, Reason: "no_exclusions", Score: 0}
        }</span>

        <span class="cov8" title="1">baseName := filepath.Base(c.Path)

        for _, pattern := range p.patterns </span><span class="cov8" title="1">{
                // Try matching against base name first (most common case)
                if matched, err := filepath.Match(pattern, baseName); err == nil &amp;&amp; matched </span><span class="cov8" title="1">{
                        return core.Decision{
                                Allow:  false,
                                Reason: "excluded:" + pattern,
                                Score:  0,
                        }
                }</span>

                // Also try matching against the full path for directory patterns
                <span class="cov8" title="1">if matched, err := filepath.Match(pattern, c.Path); err == nil &amp;&amp; matched </span><span class="cov0" title="0">{
                        return core.Decision{
                                Allow:  false,
                                Reason: "excluded:" + pattern,
                                Score:  0,
                        }
                }</span>

                // Handle ** glob patterns (recursive match)
                <span class="cov8" title="1">if matchRecursive(pattern, c.Path) </span><span class="cov8" title="1">{
                        return core.Decision{
                                Allow:  false,
                                Reason: "excluded:" + pattern,
                                Score:  0,
                        }
                }</span>
        }

        <span class="cov8" title="1">return core.Decision{Allow: true, Reason: "not_excluded", Score: 0}</span>
}

// matchRecursive handles ** patterns for recursive directory matching.
// Pattern "backup/**" matches any file under a "backup" directory.
func matchRecursive(pattern, path string) bool <span class="cov8" title="1">{
        // Check if pattern contains **
        if !containsDoubleStar(pattern) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Split pattern at **
        <span class="cov8" title="1">parts := splitAtDoubleStar(pattern)
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">prefix := parts[0]
        suffix := parts[1]

        // Remove trailing slash from prefix if present
        prefix = filepath.Clean(prefix)
        if prefix == "." </span><span class="cov0" title="0">{
                prefix = ""
        }</span>

        // Check if path starts with prefix
        <span class="cov8" title="1">if prefix != "" </span><span class="cov8" title="1">{
                // The path should contain the prefix as a directory component
                if !hasPathPrefix(path, prefix) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // If suffix is empty or just "/", any file under prefix matches
        <span class="cov8" title="1">if suffix == "" || suffix == "/" </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check if the remainder matches the suffix pattern
        <span class="cov0" title="0">suffix = filepath.Clean(suffix)
        baseName := filepath.Base(path)
        matched, _ := filepath.Match(suffix, baseName)
        return matched</span>
}

func containsDoubleStar(pattern string) bool <span class="cov8" title="1">{
        for i := 0; i &lt; len(pattern)-1; i++ </span><span class="cov8" title="1">{
                if pattern[i] == '*' &amp;&amp; pattern[i+1] == '*' </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func splitAtDoubleStar(pattern string) []string <span class="cov8" title="1">{
        for i := 0; i &lt; len(pattern)-1; i++ </span><span class="cov8" title="1">{
                if pattern[i] == '*' &amp;&amp; pattern[i+1] == '*' </span><span class="cov8" title="1">{
                        return []string{pattern[:i], pattern[i+2:]}
                }</span>
        }
        <span class="cov0" title="0">return []string{pattern}</span>
}

// hasPathPrefix checks if path contains prefix as a directory component.
func hasPathPrefix(path, prefix string) bool <span class="cov8" title="1">{
        // Clean both paths
        path = filepath.Clean(path)
        prefix = filepath.Clean(prefix)

        // Check if prefix appears as a directory name in path
        pathParts := splitPath(path)
        prefixParts := splitPath(prefix)

        if len(prefixParts) &gt; len(pathParts) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Look for prefix parts as consecutive components anywhere in path
        <span class="cov8" title="1">for i := 0; i &lt;= len(pathParts)-len(prefixParts); i++ </span><span class="cov8" title="1">{
                match := true
                for j, pp := range prefixParts </span><span class="cov8" title="1">{
                        if pathParts[i+j] != pp </span><span class="cov8" title="1">{
                                match = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if match </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func splitPath(path string) []string <span class="cov8" title="1">{
        var parts []string
        for path != "" &amp;&amp; path != "/" &amp;&amp; path != "." </span><span class="cov8" title="1">{
                dir, file := filepath.Split(path)
                if file != "" </span><span class="cov8" title="1">{
                        parts = append([]string{file}, parts...)
                }</span>
                <span class="cov8" title="1">path = filepath.Clean(dir)
                if path == "/" || path == "." </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return parts</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package policy

import (
        "context"
        "path/filepath"
        "strings"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

// ExtensionPolicy allows candidates with specific file extensions.
type ExtensionPolicy struct {
        Extensions []string // e.g., [".tmp", ".log", ".bak"]
}

// NewExtensionPolicy creates a policy that allows files matching any of the given extensions.
// Extensions should include the dot (e.g., ".tmp", ".log").
func NewExtensionPolicy(extensions []string) *ExtensionPolicy <span class="cov8" title="1">{
        // Normalize extensions to lowercase
        normalized := make([]string, len(extensions))
        for i, ext := range extensions </span><span class="cov8" title="1">{
                normalized[i] = strings.ToLower(strings.TrimSpace(ext))
        }</span>
        <span class="cov8" title="1">return &amp;ExtensionPolicy{Extensions: normalized}</span>
}

func (p *ExtensionPolicy) Evaluate(_ context.Context, c core.Candidate, _ core.EnvSnapshot) core.Decision <span class="cov8" title="1">{
        ext := strings.ToLower(filepath.Ext(c.Path))
        for _, allowed := range p.Extensions </span><span class="cov8" title="1">{
                if ext == allowed </span><span class="cov8" title="1">{
                        return core.Decision{Allow: true, Reason: "extension_match", Score: 100}
                }</span>
        }
        <span class="cov8" title="1">return core.Decision{Allow: false, Reason: "extension_mismatch", Score: 0}</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package policy

import (
        "context"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

// SizePolicy allows candidates larger than MinBytes.
type SizePolicy struct {
        MinBytes int64
}

// NewSizePolicy creates a policy that allows files &gt;= minMB megabytes.
func NewSizePolicy(minMB int) *SizePolicy <span class="cov8" title="1">{
        return &amp;SizePolicy{MinBytes: int64(minMB) * 1024 * 1024}
}</span>

func (p *SizePolicy) Evaluate(_ context.Context, c core.Candidate, _ core.EnvSnapshot) core.Decision <span class="cov8" title="1">{
        if c.SizeBytes &gt;= p.MinBytes </span><span class="cov8" title="1">{
                // Score based on size in MB (capped at 1024)
                sizeMB := int(c.SizeBytes / (1024 * 1024))
                if sizeMB &gt; 1024 </span><span class="cov0" title="0">{
                        sizeMB = 1024
                }</span>
                <span class="cov8" title="1">return core.Decision{Allow: true, Reason: "size_ok", Score: sizeMB}</span>
        }
        <span class="cov8" title="1">return core.Decision{Allow: false, Reason: "too_small", Score: 0}</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package policy

import (
        "context"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

type DenyAll struct{}

func NewDenyAll() *DenyAll <span class="cov0" title="0">{ return &amp;DenyAll{} }</span>

func (p *DenyAll) Evaluate(_ context.Context, _ core.Candidate, _ core.EnvSnapshot) core.Decision <span class="cov0" title="0">{
        return core.Decision{
                Allow:  false,
                Reason: "policy_deny_all",
        }
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package safety

import (
        "errors"
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "strings"

        "github.com/ChrisB0-2/storage-sage/internal/core"
)

const (
        ReasonOK               = "ok"
        ReasonOutsideRoot      = "outside_root"
        ReasonSymlinkAncestor  = "symlink_ancestor"
        ReasonSymlinkSelf      = "symlink_self"
        ReasonStatError        = "stat_error"
        ReasonInvalidArguments = "invalid_args"
)

type AncestorSymlinkOptions struct {
        // If true, we will NOT block when the root itself is a symlink.
        // This is often useful if the user intentionally points root at a symlinked mount path.
        AllowRootSymlink bool
}

// AncestorSymlinkContainment blocks if:
// - candidate resolves to a path outside root (string-safe check using Abs+Rel), OR
// - any component from root -&gt; candidate is a symlink (detected via Lstat without following).
//
// It does NOT follow symlinks (that's the point).
func AncestorSymlinkContainment(root, candidate string, opt AncestorSymlinkOptions) core.SafetyVerdict <span class="cov8" title="1">{
        root = strings.TrimSpace(root)
        candidate = strings.TrimSpace(candidate)

        if root == "" || candidate == "" </span><span class="cov8" title="1">{
                return core.SafetyVerdict{Allowed: false, Reason: ReasonInvalidArguments}
        }</span>

        <span class="cov8" title="1">rootAbs, err := absClean(root)
        if err != nil </span><span class="cov0" title="0">{
                return core.SafetyVerdict{Allowed: false, Reason: fmt.Sprintf("%s:root:%v", ReasonStatError, err)}
        }</span>
        <span class="cov8" title="1">candAbs, err := absClean(candidate)
        if err != nil </span><span class="cov0" title="0">{
                return core.SafetyVerdict{Allowed: false, Reason: fmt.Sprintf("%s:candidate:%v", ReasonStatError, err)}
        }</span>

        // 1) Fast must be under root check (string-safe, not symlink-safe).
        <span class="cov8" title="1">rel, err := filepath.Rel(rootAbs, candAbs)
        if err != nil </span><span class="cov0" title="0">{
                return core.SafetyVerdict{Allowed: false, Reason: fmt.Sprintf("%s:rel:%v", ReasonStatError, err)}
        }</span>
        <span class="cov8" title="1">if rel == "." </span><span class="cov8" title="1">{
                // candidate == root (rare)  treat as allowed by containment; callers can still block dirs separately.
                return core.SafetyVerdict{Allowed: true, Reason: ReasonOK}
        }</span>
        <span class="cov8" title="1">if relIsOutside(rel) </span><span class="cov8" title="1">{
                return core.SafetyVerdict{Allowed: false, Reason: ReasonOutsideRoot}
        }</span>

        // 2) Symlink ancestor check using Lstat on every component along root-&gt;candidate.
        <span class="cov8" title="1">parts := splitRel(rel)

        cur := rootAbs

        // Optional: block if root itself is a symlink (only when not allowed).
        if !opt.AllowRootSymlink </span><span class="cov8" title="1">{
                if isLink, linkErr := isSymlink(cur); linkErr != nil </span><span class="cov0" title="0">{
                        return core.SafetyVerdict{Allowed: false, Reason: fmt.Sprintf("%s:root:%v", ReasonStatError, linkErr)}
                }</span> else<span class="cov8" title="1"> if isLink </span><span class="cov8" title="1">{
                        return core.SafetyVerdict{Allowed: false, Reason: fmt.Sprintf("%s:%s", ReasonSymlinkAncestor, cur)}
                }</span>
        }

        <span class="cov8" title="1">for i, p := range parts </span><span class="cov8" title="1">{
                cur = filepath.Join(cur, p)

                isLink, linkErr := isSymlink(cur)
                if linkErr != nil </span><span class="cov8" title="1">{
                        // Strict by design: any inability to verify safety =&gt; deny.
                        return core.SafetyVerdict{Allowed: false, Reason: fmt.Sprintf("%s:%v", ReasonStatError, linkErr)}
                }</span>
                <span class="cov8" title="1">if isLink </span><span class="cov8" title="1">{
                        // If the final node is symlink, label as symlink_self; otherwise symlink_ancestor.
                        if i == len(parts)-1 </span><span class="cov8" title="1">{
                                return core.SafetyVerdict{Allowed: false, Reason: fmt.Sprintf("%s:%s", ReasonSymlinkSelf, cur)}
                        }</span>
                        <span class="cov8" title="1">return core.SafetyVerdict{Allowed: false, Reason: fmt.Sprintf("%s:%s", ReasonSymlinkAncestor, cur)}</span>
                }
        }

        <span class="cov8" title="1">return core.SafetyVerdict{Allowed: true, Reason: ReasonOK}</span>
}

func absClean(p string) (string, error) <span class="cov8" title="1">{
        // Clean first so Abs doesnt preserve oddities like "a/../b".
        clean := filepath.Clean(p)
        abs, err := filepath.Abs(clean)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return abs, nil</span>
}

func relIsOutside(rel string) bool <span class="cov8" title="1">{
        rel = filepath.Clean(rel)
        // filepath.Rel uses OS separators; outside root appears as ".." or "..&lt;sep&gt;..."
        if rel == ".." </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">prefix := ".." + string(os.PathSeparator)
        return strings.HasPrefix(rel, prefix)</span>
}

func splitRel(rel string) []string <span class="cov8" title="1">{
        rel = filepath.Clean(rel)
        if rel == "." || rel == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">sep := string(os.PathSeparator)
        return strings.Split(rel, sep)</span>
}

func isSymlink(path string) (bool, error) <span class="cov8" title="1">{
        info, err := os.Lstat(path)
        if err != nil </span><span class="cov8" title="1">{
                // If the path vanished, we treat it as an error so the caller denies.
                // (Also helps TOCTOU: unexpected changes fail closed.)
                if errors.Is(err, fs.ErrNotExist) </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("lstat:not_exist:%s", path)
                }</span>
                <span class="cov0" title="0">return false, fmt.Errorf("lstat:%s:%w", path, err)</span>
        }
        <span class="cov8" title="1">return (info.Mode() &amp; os.ModeSymlink) != 0, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package safety

import (
        "context"
        "os"
        "path/filepath"
        "strings"

        "github.com/ChrisB0-2/storage-sage/internal/core"
        "github.com/ChrisB0-2/storage-sage/internal/logger"
)

type Engine struct {
        log logger.Logger
}

// New creates a safety engine with no-op logging.
func New() *Engine <span class="cov8" title="1">{
        return &amp;Engine{log: logger.NewNop()}
}</span>

// NewWithLogger creates a safety engine with the given logger.
func NewWithLogger(log logger.Logger) *Engine <span class="cov8" title="1">{
        if log == nil </span><span class="cov8" title="1">{
                log = logger.NewNop()
        }</span>
        <span class="cov8" title="1">return &amp;Engine{log: log}</span>
}

//nolint:gocyclo // Safety validation requires comprehensive checks; refactoring would reduce clarity
func (e *Engine) Validate(_ context.Context, cand core.Candidate, cfg core.SafetyConfig) core.SafetyVerdict <span class="cov8" title="1">{
        // Normalize candidate path.
        candPath := filepath.Clean(cand.Path)

        roots := cfg.AllowedRoots
        if len(roots) == 0 &amp;&amp; strings.TrimSpace(cand.Root) != "" </span><span class="cov8" title="1">{
                roots = []string{cand.Root}
        }</span>
        // Fail-closed: if roots are enforced, candidate must carry the discovering root.
        <span class="cov8" title="1">if len(cfg.AllowedRoots) &gt; 0 &amp;&amp; strings.TrimSpace(cand.Root) == "" </span><span class="cov8" title="1">{
                return e.denyWithLog(candPath, "missing_candidate_root")
        }</span>

        // 0a) Ancestor symlink containment (fail-closed when roots are configured).
        <span class="cov8" title="1">if _, err := os.Lstat(candPath); err == nil </span><span class="cov8" title="1">{
                // Prefer scanner-provided cand.Root; otherwise derive from AllowedRoots.
                rootForContainment := strings.TrimSpace(cand.Root)
                if rootForContainment != "" </span><span class="cov8" title="1">{
                        v := AncestorSymlinkContainment(rootForContainment, cand.Path, AncestorSymlinkOptions{
                                AllowRootSymlink: true,
                        })
                        if !v.Allowed </span><span class="cov8" title="1">{
                                // Normalize internal containment reasons into public engine reasons.
                                if v.Reason == ReasonOutsideRoot </span><span class="cov8" title="1">{
                                        return e.denyWithLog(candPath, "outside_allowed_roots")
                                }</span>

                                // Upgrade symlink_self / symlink_ancestor to symlink_escape when LinkTarget escapes allowed roots.
                                <span class="cov8" title="1">if (v.Reason == ReasonSymlinkSelf || v.Reason == ReasonSymlinkAncestor) &amp;&amp;
                                        cand.IsSymlink &amp;&amp; cand.LinkTarget != "" &amp;&amp; len(cfg.AllowedRoots) &gt; 0 </span><span class="cov0" title="0">{
                                        linkTarget := cand.LinkTarget
                                        if !filepath.IsAbs(linkTarget) </span><span class="cov0" title="0">{
                                                linkTarget = filepath.Join(filepath.Dir(candPath), linkTarget)
                                        }</span>
                                        <span class="cov0" title="0">resolved := filepath.Clean(linkTarget)

                                        allowedResolved := false
                                        for _, r := range roots </span><span class="cov0" title="0">{
                                                root := filepath.Clean(r)
                                                if isPathOrChild(resolved, root) </span><span class="cov0" title="0">{
                                                        allowedResolved = true
                                                        break</span>
                                                }
                                        }
                                        <span class="cov0" title="0">if !allowedResolved </span><span class="cov0" title="0">{
                                                return e.denyWithLog(candPath, "symlink_escape")
                                        }</span>
                                }
                                <span class="cov8" title="1">e.log.Debug("safety denied", logger.F("path", candPath), logger.F("reason", v.Reason))
                                return v</span>
                        }
                }

        }

        // 0b) Mount boundary enforcement
        <span class="cov8" title="1">if cfg.EnforceMountBoundary &amp;&amp; cand.RootDeviceID != 0 &amp;&amp; cand.DeviceID != 0 </span><span class="cov8" title="1">{
                if cand.DeviceID != cand.RootDeviceID </span><span class="cov8" title="1">{
                        return e.denyWithLog(candPath, "mount_boundary")
                }</span>
        }

        // 0) Type gate: dir deletion must be explicitly allowed.
        <span class="cov8" title="1">if cand.Type == core.TargetDir &amp;&amp; !cfg.AllowDirDelete </span><span class="cov8" title="1">{
                return e.denyWithLog(candPath, "dir_delete_disabled")
        }</span>

        // 1) Protected paths: hard deny if cand is or is under any protected path.
        <span class="cov8" title="1">for _, p := range cfg.ProtectedPaths </span><span class="cov8" title="1">{
                pp := filepath.Clean(p)
                if isPathOrChild(candPath, pp) </span><span class="cov8" title="1">{
                        return e.denyWithLog(candPath, "protected_path")
                }</span>
        }

        // 2) Allowed roots: candidate path must be under at least one allowed root.
        <span class="cov8" title="1">if len(cfg.AllowedRoots) &gt; 0 </span><span class="cov8" title="1">{
                allowed := false
                for _, r := range roots </span><span class="cov8" title="1">{
                        root := filepath.Clean(r)
                        if isPathOrChild(candPath, root) </span><span class="cov8" title="1">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !allowed </span><span class="cov8" title="1">{
                        return e.denyWithLog(candPath, "outside_allowed_roots")
                }</span>
        }

        // 3) Symlink escape check: if candidate is a symlink and we know link target,
        // ensure resolved path still sits under allowed roots.
        //
        // IMPORTANT: This is a "deny on known escape" check.
        // We do not attempt filesystem reads here; scanner can provide LinkTarget.
        <span class="cov8" title="1">roots = cfg.AllowedRoots
        if len(roots) == 0 &amp;&amp; cand.Root != "" </span><span class="cov8" title="1">{
                roots = []string{cand.Root}
        }</span>
        <span class="cov8" title="1">if cand.IsSymlink &amp;&amp; cand.LinkTarget != "" &amp;&amp; len(roots) &gt; 0 </span><span class="cov8" title="1">{
                // LinkTarget may be relative; resolve relative to the symlink's directory.
                linkTarget := cand.LinkTarget
                if !filepath.IsAbs(linkTarget) </span><span class="cov8" title="1">{
                        linkTarget = filepath.Join(filepath.Dir(candPath), linkTarget)
                }</span>
                <span class="cov8" title="1">resolved := filepath.Clean(linkTarget)

                allowed := false
                for _, r := range roots </span><span class="cov8" title="1">{
                        root := filepath.Clean(r)
                        if isPathOrChild(resolved, root) </span><span class="cov8" title="1">{
                                allowed = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !allowed </span><span class="cov8" title="1">{
                        return e.denyWithLog(candPath, "symlink_escape")
                }</span>
        }

        <span class="cov8" title="1">return allow("ok")</span>
}

func allow(reason string) core.SafetyVerdict <span class="cov8" title="1">{
        return core.SafetyVerdict{Allowed: true, Reason: reason}
}</span>

func deny(reason string) core.SafetyVerdict <span class="cov8" title="1">{
        return core.SafetyVerdict{Allowed: false, Reason: reason}
}</span>

// denyWithLog creates a deny verdict and logs it.
func (e *Engine) denyWithLog(path, reason string) core.SafetyVerdict <span class="cov8" title="1">{
        e.log.Debug("safety denied", logger.F("path", path), logger.F("reason", reason))
        return deny(reason)
}</span>

// isPathOrChild returns true if path == base OR path is a child of base.
// This avoids prefix bugs like "/data/a" matching "/data/abc".
func isPathOrChild(path, base string) bool <span class="cov8" title="1">{
        path = filepath.Clean(path)
        base = filepath.Clean(base)

        // Special case: "/" should only match "/" exactly.
        if base == string(filepath.Separator) </span><span class="cov8" title="1">{
                return path == base
        }</span>

        <span class="cov8" title="1">if path == base </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">baseWithSep := base
        if !strings.HasSuffix(baseWithSep, string(filepath.Separator)) </span><span class="cov8" title="1">{
                baseWithSep += string(filepath.Separator)
        }</span>
        <span class="cov8" title="1">return strings.HasPrefix(path, baseWithSep)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">//go:build unix

package scanner

import (
        "os"
        "syscall"
)

// getDeviceID extracts the device ID from file stat info on Unix systems.
func getDeviceID(info os.FileInfo) (uint64, bool) <span class="cov8" title="1">{
        stat, ok := info.Sys().(*syscall.Stat_t)
        if !ok </span><span class="cov0" title="0">{
                return 0, false
        }</span>
        //nolint:unconvert // stat.Dev type varies by platform (int32 on some, uint64 on others)
        <span class="cov8" title="1">return uint64(stat.Dev), true</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package scanner

import (
        "context"
        "io/fs"
        "os"
        "path/filepath"
        "time"

        "github.com/ChrisB0-2/storage-sage/internal/core"
        "github.com/ChrisB0-2/storage-sage/internal/logger"
        "github.com/ChrisB0-2/storage-sage/internal/metrics"
)

type WalkDirScanner struct {
        log     logger.Logger
        metrics core.Metrics
}

// NewWalkDir creates a scanner with no-op logging and metrics.
func NewWalkDir() *WalkDirScanner <span class="cov8" title="1">{
        return &amp;WalkDirScanner{
                log:     logger.NewNop(),
                metrics: metrics.NewNoop(),
        }
}</span>

// NewWalkDirWithLogger creates a scanner with the given logger.
func NewWalkDirWithLogger(log logger.Logger) *WalkDirScanner <span class="cov0" title="0">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.NewNop()
        }</span>
        <span class="cov0" title="0">return &amp;WalkDirScanner{
                log:     log,
                metrics: metrics.NewNoop(),
        }</span>
}

// NewWalkDirWithMetrics creates a scanner with logger and metrics.
func NewWalkDirWithMetrics(log logger.Logger, m core.Metrics) *WalkDirScanner <span class="cov0" title="0">{
        if log == nil </span><span class="cov0" title="0">{
                log = logger.NewNop()
        }</span>
        <span class="cov0" title="0">if m == nil </span><span class="cov0" title="0">{
                m = metrics.NewNoop()
        }</span>
        <span class="cov0" title="0">return &amp;WalkDirScanner{
                log:     log,
                metrics: m,
        }</span>
}

// Scan walks each root and emits Candidates. It never deletes.
//
//nolint:gocyclo // Filesystem walking has inherent complexity; splitting would hurt readability
func (s *WalkDirScanner) Scan(ctx context.Context, req core.ScanRequest) (&lt;-chan core.Candidate, &lt;-chan error) <span class="cov8" title="1">{
        out := make(chan core.Candidate, 128)
        errc := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                defer close(out)
                defer close(errc)

                s.log.Debug("scan starting", logger.F("roots", req.Roots), logger.F("max_depth", req.MaxDepth))

                for _, root := range req.Roots </span><span class="cov8" title="1">{
                        root = filepath.Clean(root)
                        if absRoot, err := filepath.Abs(root); err == nil </span><span class="cov8" title="1">{
                                root = absRoot
                        }</span>

                        // Get root device ID for mount boundary detection
                        <span class="cov8" title="1">var rootDeviceID uint64
                        if rootInfo, err := os.Lstat(root); err == nil </span><span class="cov8" title="1">{
                                if devID, ok := getDeviceID(rootInfo); ok </span><span class="cov8" title="1">{
                                        rootDeviceID = devID
                                }</span>
                        }

                        <span class="cov8" title="1">scanStart := time.Now()
                        walkErr := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                                if err != nil </span><span class="cov0" title="0">{
                                        // Log permission/access errors and skip, rather than failing the entire scan.
                                        s.log.Debug("skipping inaccessible path", logger.F("path", path), logger.F("error", err.Error()))
                                        // For directories, return SkipDir to avoid descending; for files, return nil to continue.
                                        if d != nil &amp;&amp; d.IsDir() </span><span class="cov0" title="0">{
                                                return fs.SkipDir
                                        }</span>
                                        <span class="cov0" title="0">return nil</span>
                                }

                                <span class="cov8" title="1">select </span>{
                                case &lt;-ctx.Done():<span class="cov8" title="1">
                                        return ctx.Err()</span>
                                default:<span class="cov8" title="1"></span>
                                }

                                <span class="cov8" title="1">if req.MaxDepth &gt; 0 </span><span class="cov8" title="1">{
                                        rel, relErr := filepath.Rel(root, path)
                                        if relErr == nil </span><span class="cov8" title="1">{
                                                depth := 0
                                                for _, r := range rel </span><span class="cov8" title="1">{
                                                        if r == filepath.Separator </span><span class="cov8" title="1">{
                                                                depth++
                                                        }</span>
                                                }
                                                <span class="cov8" title="1">if depth &gt;= req.MaxDepth &amp;&amp; d.IsDir() </span><span class="cov8" title="1">{
                                                        return fs.SkipDir
                                                }</span>
                                        }
                                }

                                <span class="cov8" title="1">var tt core.TargetType
                                if d.IsDir() </span><span class="cov8" title="1">{
                                        tt = core.TargetDir
                                }</span> else<span class="cov8" title="1"> {
                                        tt = core.TargetFile
                                }</span>

                                <span class="cov8" title="1">if (tt == core.TargetDir &amp;&amp; !req.IncludeDirs) || (tt == core.TargetFile &amp;&amp; !req.IncludeFiles) </span><span class="cov8" title="1">{
                                        return nil
                                }</span>

                                <span class="cov8" title="1">info, infoErr := d.Info()
                                if infoErr != nil </span><span class="cov0" title="0">{
                                        return infoErr
                                }</span>
                                <span class="cov8" title="1">size := int64(0)
                                if !d.IsDir() </span><span class="cov8" title="1">{
                                        size = info.Size()
                                }</span>
                                <span class="cov8" title="1">candPath := filepath.Clean(path)
                                if absPath, err := filepath.Abs(candPath); err == nil </span><span class="cov8" title="1">{
                                        candPath = absPath
                                }</span>

                                <span class="cov8" title="1">c := core.Candidate{
                                        Root:         root,
                                        Path:         candPath,
                                        Type:         tt,
                                        ModTime:      info.ModTime(),
                                        FoundAt:      time.Now(),
                                        SizeBytes:    size,
                                        RootDeviceID: rootDeviceID,
                                }

                                // Extract file's device ID
                                if deviceID, ok := getDeviceID(info); ok </span><span class="cov8" title="1">{
                                        c.DeviceID = deviceID
                                }</span>

                                <span class="cov8" title="1">if d.Type()&amp;fs.ModeSymlink != 0 </span><span class="cov8" title="1">{
                                        c.IsSymlink = true

                                        // Record the symlink target for safety checks.
                                        if link, err := os.Readlink(path); err == nil </span><span class="cov8" title="1">{
                                                // If the link is relative, interpret it relative to the symlink's directory.
                                                if !filepath.IsAbs(link) </span><span class="cov0" title="0">{
                                                        link = filepath.Join(filepath.Dir(path), link)
                                                }</span>

                                                // Prefer absolute, cleaned target.
                                                <span class="cov8" title="1">if abs, err := filepath.Abs(link); err == nil </span><span class="cov8" title="1">{
                                                        c.LinkTarget = abs
                                                }</span> else<span class="cov0" title="0"> {
                                                        c.LinkTarget = filepath.Clean(link)
                                                }</span>
                                        }
                                }

                                // Record metrics
                                <span class="cov8" title="1">if tt == core.TargetFile </span><span class="cov8" title="1">{
                                        s.metrics.IncFilesScanned(root)
                                }</span> else<span class="cov8" title="1"> {
                                        s.metrics.IncDirsScanned(root)
                                }</span>

                                <span class="cov8" title="1">out &lt;- c
                                return nil</span>
                        })

                        // Record scan duration for this root
                        <span class="cov8" title="1">s.metrics.ObserveScanDuration(root, time.Since(scanStart))

                        if walkErr != nil </span><span class="cov8" title="1">{
                                s.log.Warn("scan error", logger.F("root", root), logger.F("error", walkErr.Error()))
                                errc &lt;- walkErr
                                return
                        }</span>
                        <span class="cov8" title="1">s.log.Debug("root scan complete", logger.F("root", root))</span>
                }
                <span class="cov8" title="1">s.log.Debug("scan complete")</span>
        }()

        <span class="cov8" title="1">return out, errc</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Package trash provides soft-delete functionality by moving files
// to a trash directory instead of permanently deleting them.
package trash

import (
        "context"
        "crypto/sha256"
        "encoding/hex"
        "fmt"
        "io/fs"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/ChrisB0-2/storage-sage/internal/logger"
)

// Manager handles soft-delete operations by moving files to a trash directory.
type Manager struct {
        trashPath string
        maxAge    time.Duration
        log       logger.Logger
}

// Config configures the trash manager.
type Config struct {
        // TrashPath is the directory where deleted files are moved.
        // If empty, soft-delete is disabled and files are permanently deleted.
        TrashPath string

        // MaxAge is the maximum age of trashed files before they are permanently deleted.
        // Zero means files are kept forever (manual cleanup required).
        MaxAge time.Duration
}

// New creates a new trash manager.
// Returns nil if trash is disabled (empty TrashPath).
func New(cfg Config, log logger.Logger) (*Manager, error) <span class="cov8" title="1">{
        if cfg.TrashPath == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">if log == nil </span><span class="cov8" title="1">{
                log = logger.NewNop()
        }</span>

        // Ensure trash directory exists
        <span class="cov8" title="1">if err := os.MkdirAll(cfg.TrashPath, 0755); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("creating trash directory: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;Manager{
                trashPath: cfg.TrashPath,
                maxAge:    cfg.MaxAge,
                log:       log,
        }, nil</span>
}

// MoveToTrash moves a file or directory to the trash.
// Returns the path in the trash where the item was moved.
func (m *Manager) MoveToTrash(path string) (trashPath string, err error) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("trash manager is nil (soft-delete disabled)")
        }</span>

        // Get file info for metadata
        <span class="cov8" title="1">info, err := os.Lstat(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("stat failed: %w", err)
        }</span>

        // Generate a unique name to avoid collisions
        // Format: YYYYMMDD-HHMMSS_hash_originalname
        <span class="cov8" title="1">timestamp := time.Now().Format("20060102-150405")
        hash := hashPath(path)
        baseName := filepath.Base(path)

        // Sanitize the base name (remove path separators that might cause issues)
        safeName := strings.ReplaceAll(baseName, string(os.PathSeparator), "_")
        if len(safeName) &gt; 100 </span><span class="cov8" title="1">{
                safeName = safeName[:100] // Truncate very long names
        }</span>

        <span class="cov8" title="1">trashName := fmt.Sprintf("%s_%s_%s", timestamp, hash[:8], safeName)
        trashPath = filepath.Join(m.trashPath, trashName)

        // Create metadata file
        metaPath := trashPath + ".meta"
        meta := fmt.Sprintf("original_path: %s\ntrashed_at: %s\nsize: %d\nmode: %s\nmod_time: %s\n",
                path,
                time.Now().Format(time.RFC3339),
                info.Size(),
                info.Mode().String(),
                info.ModTime().Format(time.RFC3339),
        )

        // Move the file/directory
        if err := os.Rename(path, trashPath); err != nil </span><span class="cov0" title="0">{
                // If rename fails (cross-device), fall back to copy+delete
                if err := copyAndDelete(path, trashPath, info); err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("move to trash failed: %w", err)
                }</span>
        }

        // Write metadata (best effort - don't fail if this fails)
        <span class="cov8" title="1">if err := os.WriteFile(metaPath, []byte(meta), 0644); err != nil </span><span class="cov0" title="0">{
                m.log.Warn("failed to write trash metadata", logger.F("path", metaPath), logger.F("error", err.Error()))
        }</span>

        <span class="cov8" title="1">m.log.Debug("moved to trash", logger.F("original", path), logger.F("trash", trashPath))

        return trashPath, nil</span>
}

// Cleanup removes files from trash that are older than maxAge.
// Returns the number of items removed and bytes freed.
func (m *Manager) Cleanup(ctx context.Context) (count int, bytesFreed int64, err error) <span class="cov8" title="1">{
        if m == nil || m.maxAge == 0 </span><span class="cov8" title="1">{
                return 0, 0, nil // No cleanup needed
        }</span>

        <span class="cov8" title="1">cutoff := time.Now().Add(-m.maxAge)

        err = filepath.WalkDir(m.trashPath, func(path string, d fs.DirEntry, walkErr error) error </span><span class="cov8" title="1">{
                if walkErr != nil </span><span class="cov8" title="1">{
                        return nil // Skip errors
                }</span>

                // Check for context cancellation
                <span class="cov8" title="1">select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                default:<span class="cov8" title="1"></span>
                }

                // Skip the trash root and metadata files
                <span class="cov8" title="1">if path == m.trashPath || strings.HasSuffix(path, ".meta") </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Only process top-level items in trash
                <span class="cov8" title="1">if filepath.Dir(path) != m.trashPath </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">info, err := d.Info()
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // Check if older than cutoff (use mod time which was set when trashed)
                <span class="cov8" title="1">if info.ModTime().Before(cutoff) </span><span class="cov8" title="1">{
                        var size int64

                        if d.IsDir() </span><span class="cov8" title="1">{
                                // Calculate directory size
                                _ = filepath.WalkDir(path, func(_ string, de fs.DirEntry, _ error) error </span><span class="cov8" title="1">{
                                        if !de.IsDir() </span><span class="cov8" title="1">{
                                                if fi, err := de.Info(); err == nil </span><span class="cov8" title="1">{
                                                        size += fi.Size()
                                                }</span>
                                        }
                                        <span class="cov8" title="1">return nil</span>
                                })
                                <span class="cov8" title="1">err = os.RemoveAll(path)</span>
                        } else<span class="cov8" title="1"> {
                                size = info.Size()
                                err = os.Remove(path)
                        }</span>

                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                m.log.Warn("failed to cleanup trash item", logger.F("path", path), logger.F("error", err.Error()))
                                return nil
                        }</span>

                        // Also remove metadata file
                        <span class="cov8" title="1">_ = os.Remove(path + ".meta")

                        count++
                        bytesFreed += size

                        m.log.Debug("removed expired trash item", logger.F("path", path), logger.F("age", time.Since(info.ModTime())))</span>
                }

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">if err != nil &amp;&amp; err != context.Canceled </span><span class="cov0" title="0">{
                return count, bytesFreed, fmt.Errorf("trash cleanup walk failed: %w", err)
        }</span>

        <span class="cov8" title="1">if count &gt; 0 </span><span class="cov8" title="1">{
                m.log.Info("trash cleanup completed", logger.F("items_removed", count), logger.F("bytes_freed", bytesFreed))
        }</span>

        <span class="cov8" title="1">return count, bytesFreed, nil</span>
}

// Restore restores a file from trash to its original location.
func (m *Manager) Restore(trashPath string) (originalPath string, err error) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("trash manager is nil")
        }</span>

        // Read metadata to get original path
        <span class="cov8" title="1">metaPath := trashPath + ".meta"
        metaData, err := os.ReadFile(metaPath)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("reading trash metadata: %w", err)
        }</span>

        // Parse original path from metadata
        <span class="cov8" title="1">for _, line := range strings.Split(string(metaData), "\n") </span><span class="cov8" title="1">{
                if strings.HasPrefix(line, "original_path: ") </span><span class="cov8" title="1">{
                        originalPath = strings.TrimPrefix(line, "original_path: ")
                        break</span>
                }
        }

        <span class="cov8" title="1">if originalPath == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("original path not found in metadata")
        }</span>

        // Ensure parent directory exists
        <span class="cov8" title="1">if err := os.MkdirAll(filepath.Dir(originalPath), 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("creating parent directory: %w", err)
        }</span>

        // Move back
        <span class="cov8" title="1">if err := os.Rename(trashPath, originalPath); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("restore failed: %w", err)
        }</span>

        // Remove metadata file
        <span class="cov8" title="1">_ = os.Remove(metaPath)

        m.log.Info("restored from trash", logger.F("trash", trashPath), logger.F("original", originalPath))

        return originalPath, nil</span>
}

// List returns all items currently in trash.
func (m *Manager) List() ([]TrashItem, error) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var items []TrashItem

        entries, err := os.ReadDir(m.trashPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("reading trash directory: %w", err)
        }</span>

        <span class="cov8" title="1">for _, entry := range entries </span><span class="cov8" title="1">{
                // Skip metadata files
                if strings.HasSuffix(entry.Name(), ".meta") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">path := filepath.Join(m.trashPath, entry.Name())
                info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">item := TrashItem{
                        TrashPath: path,
                        Name:      entry.Name(),
                        Size:      info.Size(),
                        TrashedAt: info.ModTime(),
                        IsDir:     entry.IsDir(),
                }

                // Try to read original path from metadata
                if metaData, err := os.ReadFile(path + ".meta"); err == nil </span><span class="cov8" title="1">{
                        for _, line := range strings.Split(string(metaData), "\n") </span><span class="cov8" title="1">{
                                if strings.HasPrefix(line, "original_path: ") </span><span class="cov8" title="1">{
                                        item.OriginalPath = strings.TrimPrefix(line, "original_path: ")
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">items = append(items, item)</span>
        }

        <span class="cov8" title="1">return items, nil</span>
}

// TrashItem represents an item in the trash.
type TrashItem struct {
        TrashPath    string
        OriginalPath string
        Name         string
        Size         int64
        TrashedAt    time.Time
        IsDir        bool
}

// hashPath generates a short hash of the path for unique naming.
func hashPath(path string) string <span class="cov8" title="1">{
        h := sha256.Sum256([]byte(path))
        return hex.EncodeToString(h[:])
}</span>

// copyAndDelete copies a file/directory and then deletes the original.
// Used when rename fails (e.g., cross-device move).
func copyAndDelete(src, dst string, info os.FileInfo) error <span class="cov0" title="0">{
        if info.IsDir() </span><span class="cov0" title="0">{
                return copyDirAndDelete(src, dst)
        }</span>
        <span class="cov0" title="0">return copyFileAndDelete(src, dst, info.Mode())</span>
}

func copyFileAndDelete(src, dst string, mode os.FileMode) error <span class="cov0" title="0">{
        data, err := os.ReadFile(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(dst, data, mode); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.Remove(src)</span>
}

func copyDirAndDelete(src, dst string) error <span class="cov0" title="0">{
        if err := os.MkdirAll(dst, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err := filepath.WalkDir(src, func(path string, d fs.DirEntry, walkErr error) error </span><span class="cov0" title="0">{
                if walkErr != nil </span><span class="cov0" title="0">{
                        return walkErr
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(src, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">dstPath := filepath.Join(dst, relPath)

                if d.IsDir() </span><span class="cov0" title="0">{
                        return os.MkdirAll(dstPath, 0755)
                }</span>

                <span class="cov0" title="0">info, err := d.Info()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">data, err := os.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return os.WriteFile(dstPath, data, info.Mode())</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return os.RemoveAll(src)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package web

import (
        "embed"
        "io/fs"
)

//go:embed dist/*
var distFS embed.FS

// DistFS returns the embedded filesystem containing the frontend build artifacts.
// Returns an fs.FS rooted at the dist/ directory.
func DistFS() (fs.FS, error) <span class="cov0" title="0">{
        return fs.Sub(distFS, "dist")
}</span>

// HasDist returns true if the dist directory contains files.
// This is used to check if the frontend has been built.
func HasDist() bool <span class="cov0" title="0">{
        entries, err := fs.ReadDir(distFS, "dist")
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return len(entries) &gt; 0</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
