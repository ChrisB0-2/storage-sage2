package safety

import (
	"context"
	"path/filepath"
	"strings"

	"github.com/ChrisB0-2/storage-sage/internal/core"
)

type Engine struct{}

func New() *Engine { return &Engine{} }

func (e *Engine) Validate(_ context.Context, cand core.Candidate, cfg core.SafetyConfig) core.SafetyVerdict {
	// Normalize candidate path.
	candPath := filepath.Clean(cand.Path)

	// 0a) Ancestor symlink containment (fail-closed when roots are configured).
	// Prefer scanner-provided cand.Root; otherwise derive from AllowedRoots.
	rootForContainment := strings.TrimSpace(cand.Root)
	if rootForContainment == "" && len(cfg.AllowedRoots) > 0 {
		for _, r := range cfg.AllowedRoots {
			root := filepath.Clean(r)
			if isPathOrChild(candPath, root) {
				rootForContainment = root
				break
			}
		}
		if rootForContainment == "" {
			return deny("outside_allowed_roots")
		}
	}
	if rootForContainment != "" {
		v := AncestorSymlinkContainment(rootForContainment, cand.Path, AncestorSymlinkOptions{
			AllowRootSymlink: true,
		})
		if !v.Allowed {
			return v
		}
	}

	// 0) Type gate: dir deletion must be explicitly allowed.
	if cand.Type == core.TargetDir && !cfg.AllowDirDelete {
		return deny("dir_delete_disabled")
	}

	// 1) Protected paths: hard deny if cand is or is under any protected path.
	for _, p := range cfg.ProtectedPaths {
		pp := filepath.Clean(p)
		if isPathOrChild(candPath, pp) {
			return deny("protected_path")
		}
	}

	// 2) Allowed roots: candidate path must be under at least one allowed root.
	if len(cfg.AllowedRoots) > 0 {
		allowed := false
		for _, r := range cfg.AllowedRoots {
			root := filepath.Clean(r)
			if isPathOrChild(candPath, root) {
				allowed = true
				break
			}
		}
		if !allowed {
			return deny("outside_allowed_roots")
		}
	}

	// 3) Symlink escape check: if candidate is a symlink and we know link target,
	// ensure resolved path still sits under allowed roots.
	//
	// IMPORTANT: This is a "deny on known escape" check.
	// We do not attempt filesystem reads here; scanner can provide LinkTarget.
	if cand.IsSymlink && cand.LinkTarget != "" && len(cfg.AllowedRoots) > 0 {
		// LinkTarget may be relative; resolve relative to the symlink's directory.
		linkTarget := cand.LinkTarget
		if !filepath.IsAbs(linkTarget) {
			linkTarget = filepath.Join(filepath.Dir(candPath), linkTarget)
		}
		resolved := filepath.Clean(linkTarget)

		allowed := false
		for _, r := range cfg.AllowedRoots {
			root := filepath.Clean(r)
			if isPathOrChild(resolved, root) {
				allowed = true
				break
			}
		}
		if !allowed {
			return deny("symlink_escape")
		}
	}

	return allow("ok")
}

func allow(reason string) core.SafetyVerdict {
	return core.SafetyVerdict{Allowed: true, Reason: reason}
}
func deny(reason string) core.SafetyVerdict {
	return core.SafetyVerdict{Allowed: false, Reason: reason}
}

// isPathOrChild returns true if path == base OR path is a child of base.
// This avoids prefix bugs like "/data/a" matching "/data/abc".
func isPathOrChild(path, base string) bool {
	path = filepath.Clean(path)
	base = filepath.Clean(base)

	// Special case: "/" should only match "/" exactly.
	if base == string(filepath.Separator) {
		return path == base
	}

	if path == base {
		return true
	}

	baseWithSep := base
	if !strings.HasSuffix(baseWithSep, string(filepath.Separator)) {
		baseWithSep += string(filepath.Separator)
	}
	return strings.HasPrefix(path, baseWithSep)
}
